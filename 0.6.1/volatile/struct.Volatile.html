<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Wraps a reference to make accesses to the referenced value volatile."><title>Volatile in volatile - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="volatile" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0-nightly (d8a38b000 2024-06-19)" data-channel="nightly" data-search-js="search-0fe7219eb170c82e.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../volatile/index.html">volatile</a><span class="version">0.4.6</span></h2></div><h2 class="location"><a href="#">Volatile</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.as_mut_slice">as_mut_slice</a></li><li><a href="#method.as_slice">as_slice</a></li><li><a href="#method.copy_from_slice">copy_from_slice</a></li><li><a href="#method.copy_into_slice">copy_into_slice</a></li><li><a href="#method.copy_within">copy_within</a></li><li><a href="#method.extract_inner">extract_inner</a></li><li><a href="#method.fill">fill</a></li><li><a href="#method.index">index</a></li><li><a href="#method.index_mut">index_mut</a></li><li><a href="#method.map">map</a></li><li><a href="#method.map_mut">map_mut</a></li><li><a href="#method.new">new</a></li><li><a href="#method.new_read_only">new_read_only</a></li><li><a href="#method.new_write_only">new_write_only</a></li><li><a href="#method.read">read</a></li><li><a href="#method.read_only">read_only</a></li><li><a href="#method.update">update</a></li><li><a href="#method.write">write</a></li><li><a href="#method.write_only">write_only</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-Volatile%3CR,+A%3E">Clone</a></li><li><a href="#impl-Debug-for-Volatile%3CR,+A%3E">Debug</a></li><li><a href="#impl-Debug-for-Volatile%3CR,+WriteOnly%3E">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-Volatile%3CR,+A%3E">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Volatile%3CR,+A%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Volatile%3CR,+A%3E">Send</a></li><li><a href="#impl-Sync-for-Volatile%3CR,+A%3E">Sync</a></li><li><a href="#impl-Unpin-for-Volatile%3CR,+A%3E">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Volatile%3CR,+A%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In crate volatile</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="index.html">volatile</a>::<wbr><a class="struct" href="#">Volatile</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/volatile/lib.rs.html#47-50">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct Volatile&lt;R, A = <a class="struct" href="access/struct.ReadWrite.html" title="struct volatile::access::ReadWrite">ReadWrite</a>&gt; { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Wraps a reference to make accesses to the referenced value volatile.</p>
<p>Allows volatile reads and writes on the referenced value. The referenced value needs to
be <code>Copy</code> for reading and writing, as volatile reads and writes take and return copies
of the value.</p>
<p>Since not all volatile resources (e.g. memory mapped device registers) are both readable
and writable, this type supports limiting the allowed access types through an optional second
generic parameter <code>A</code> that can be one of <code>ReadWrite</code>, <code>ReadOnly</code>, or <code>WriteOnly</code>. It defaults
to <code>ReadWrite</code>, which allows all operations.</p>
<p>The size of this struct is the same as the size of the contained reference.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Volatile%3CR%3E" class="impl"><a class="src rightside" href="../src/volatile/lib.rs.html#57-161">source</a><a href="#impl-Volatile%3CR%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;R&gt;</h3></section></summary><div class="docblock"><p>Constructor functions for creating new values</p>
<p>These functions allow to construct a new <code>Volatile</code> instance from a reference type. While
the <code>new</code> function creates a <code>Volatile</code> instance with unrestricted access, there are also
functions for creating read-only or write-only instances.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../src/volatile/lib.rs.html#79-84">source</a><h4 class="code-header">pub const fn <a href="#method.new" class="fn">new</a>(reference: R) -&gt; <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;R&gt;</h4></section></summary><div class="docblock"><p>Constructs a new volatile instance wrapping the given reference.</p>
<p>While it is possible to construct <code>Volatile</code> instances from arbitrary values (including
non-reference values), most of the methods are only available when the wrapped type is
a reference. The only reason that we don’t forbid non-reference types in the constructor
functions is that the Rust compiler does not support trait bounds on generic <code>const</code>
functions yet. When this becomes possible, we will release a new version of this library
with removed support for non-references. For these reasons it is recommended to use
the <code>Volatile</code> type only with references.</p>
<h6 id="example"><a class="doc-anchor" href="#example">§</a>Example</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">let </span><span class="kw-2">mut </span>value = <span class="number">0u32</span>;

<span class="kw">let </span><span class="kw-2">mut </span>volatile = Volatile::new(<span class="kw-2">&amp;mut </span>value);
volatile.write(<span class="number">1</span>);
<span class="macro">assert_eq!</span>(volatile.read(), <span class="number">1</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new_read_only" class="method"><a class="src rightside" href="../src/volatile/lib.rs.html#117-122">source</a><h4 class="code-header">pub const fn <a href="#method.new_read_only" class="fn">new_read_only</a>(reference: R) -&gt; <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;R, <a class="struct" href="access/struct.ReadOnly.html" title="struct volatile::access::ReadOnly">ReadOnly</a>&gt;</h4></section></summary><div class="docblock"><p>Constructs a new read-only volatile instance wrapping the given reference.</p>
<p>This is equivalent to the <code>new</code> function with the difference that the returned
<code>Volatile</code> instance does not permit write operations. This is for example useful
with memory-mapped hardware registers that are defined as read-only by the hardware.</p>
<h6 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h6>
<p>Reading is allowed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">let </span>value = <span class="number">0u32</span>;

<span class="kw">let </span>volatile = Volatile::new_read_only(<span class="kw-2">&amp;</span>value);
<span class="macro">assert_eq!</span>(volatile.read(), <span class="number">0</span>);</code></pre></div>
<p>But writing is not:</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">let </span><span class="kw-2">mut </span>value = <span class="number">0u32</span>;

<span class="kw">let </span><span class="kw-2">mut </span>volatile = Volatile::new_read_only(<span class="kw-2">&amp;mut </span>value);
volatile.write(<span class="number">1</span>);
<span class="comment">//ERROR: ^^^^^ the trait `volatile::access::Writable` is not implemented
//             for `volatile::access::ReadOnly`</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new_write_only" class="method"><a class="src rightside" href="../src/volatile/lib.rs.html#155-160">source</a><h4 class="code-header">pub const fn <a href="#method.new_write_only" class="fn">new_write_only</a>(reference: R) -&gt; <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;R, <a class="struct" href="access/struct.WriteOnly.html" title="struct volatile::access::WriteOnly">WriteOnly</a>&gt;</h4></section></summary><div class="docblock"><p>Constructs a new write-only volatile instance wrapping the given reference.</p>
<p>This is equivalent to the <code>new</code> function with the difference that the returned
<code>Volatile</code> instance does not permit read operations. This is for example useful
with memory-mapped hardware registers that are defined as write-only by the hardware.</p>
<h6 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h6>
<p>Writing is allowed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">let </span><span class="kw-2">mut </span>value = <span class="number">0u32</span>;

<span class="kw">let </span><span class="kw-2">mut </span>volatile = Volatile::new_write_only(<span class="kw-2">&amp;mut </span>value);
volatile.write(<span class="number">1</span>);</code></pre></div>
<p>But reading is not:</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">let </span>value = <span class="number">0u32</span>;

<span class="kw">let </span>volatile = Volatile::new_write_only(<span class="kw-2">&amp;</span>value);
volatile.read();
<span class="comment">//ERROR: ^^^^ the trait `volatile::access::Readable` is not implemented
//            for `volatile::access::WriteOnly`</span></code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Volatile%3CR,+A%3E" class="impl"><a class="src rightside" href="../src/volatile/lib.rs.html#164-248">source</a><a href="#impl-Volatile%3CR,+A%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R, T, A&gt; <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;R, A&gt;<div class="where">where
    R: Deref&lt;Target = T&gt;,
    T: Copy,</div></h3></section></summary><div class="docblock"><p>Methods for references to <code>Copy</code> types</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.read" class="method"><a class="src rightside" href="../src/volatile/lib.rs.html#189-195">source</a><h4 class="code-header">pub fn <a href="#method.read" class="fn">read</a>(&amp;self) -&gt; T<div class="where">where
    A: <a class="trait" href="access/trait.Readable.html" title="trait volatile::access::Readable">Readable</a>,</div></h4></section></summary><div class="docblock"><p>Performs a volatile read of the contained value.</p>
<p>Returns a copy of the read value. Volatile reads are guaranteed not to be optimized
away by the compiler, but by themselves do not have atomic ordering
guarantees. To also get atomicity, consider looking at the <code>Atomic</code> wrapper types of
the standard/<code>core</code> library.</p>
<h6 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">let </span>value = <span class="number">42</span>;
<span class="kw">let </span>shared_reference = Volatile::new(<span class="kw-2">&amp;</span>value);
<span class="macro">assert_eq!</span>(shared_reference.read(), <span class="number">42</span>);

<span class="kw">let </span><span class="kw-2">mut </span>value = <span class="number">50</span>;
<span class="kw">let </span>mut_reference = Volatile::new(<span class="kw-2">&amp;mut </span>value);
<span class="macro">assert_eq!</span>(mut_reference.read(), <span class="number">50</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write" class="method"><a class="src rightside" href="../src/volatile/lib.rs.html#214-221">source</a><h4 class="code-header">pub fn <a href="#method.write" class="fn">write</a>(&amp;mut self, value: T)<div class="where">where
    A: <a class="trait" href="access/trait.Writable.html" title="trait volatile::access::Writable">Writable</a>,
    R: DerefMut,</div></h4></section></summary><div class="docblock"><p>Performs a volatile write, setting the contained value to the given <code>value</code>.</p>
<p>Volatile writes are guaranteed to not be optimized away by the compiler, but by
themselves do not have atomic ordering guarantees. To also get atomicity, consider
looking at the <code>Atomic</code> wrapper types of the standard/<code>core</code> library.</p>
<h6 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">let </span><span class="kw-2">mut </span>value = <span class="number">42</span>;
<span class="kw">let </span><span class="kw-2">mut </span>volatile = Volatile::new(<span class="kw-2">&amp;mut </span>value);
volatile.write(<span class="number">50</span>);

<span class="macro">assert_eq!</span>(volatile.read(), <span class="number">50</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.update" class="method"><a class="src rightside" href="../src/volatile/lib.rs.html#238-247">source</a><h4 class="code-header">pub fn <a href="#method.update" class="fn">update</a>&lt;F&gt;(&amp;mut self, f: F)<div class="where">where
    A: <a class="trait" href="access/trait.Readable.html" title="trait volatile::access::Readable">Readable</a> + <a class="trait" href="access/trait.Writable.html" title="trait volatile::access::Writable">Writable</a>,
    R: DerefMut,
    F: FnOnce(&amp;mut T),</div></h4></section></summary><div class="docblock"><p>Updates the contained value using the given closure and volatile instructions.</p>
<p>Performs a volatile read of the contained value, passes a mutable reference to it to the
function <code>f</code>, and then performs a volatile write of the (potentially updated) value back to
the contained value.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">let </span><span class="kw-2">mut </span>value = <span class="number">42</span>;
<span class="kw">let </span><span class="kw-2">mut </span>volatile = Volatile::new(<span class="kw-2">&amp;mut </span>value);
volatile.update(|val| <span class="kw-2">*</span>val += <span class="number">1</span>);

<span class="macro">assert_eq!</span>(volatile.read(), <span class="number">43</span>);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Volatile%3CR,+A%3E-1" class="impl"><a class="src rightside" href="../src/volatile/lib.rs.html#251-279">source</a><a href="#impl-Volatile%3CR,+A%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;R, A&gt; <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;R, A&gt;</h3></section></summary><div class="docblock"><p>Method for extracting the wrapped value.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.extract_inner" class="method"><a class="src rightside" href="../src/volatile/lib.rs.html#276-278">source</a><h4 class="code-header">pub fn <a href="#method.extract_inner" class="fn">extract_inner</a>(self) -&gt; R</h4></section></summary><div class="docblock"><p>Extracts the inner value stored in the wrapper type.</p>
<p>This method gives direct access to the wrapped reference and thus allows
non-volatile access again. This is seldom what you want since there is usually
a reason that a reference is wrapped in <code>Volatile</code>. However, in some cases it might
be required or useful to use the <code>read_volatile</code>/<code>write_volatile</code> pointer methods of
the standard library directly, which this method makes possible.</p>
<p>Since no memory safety violation can occur when accessing the referenced value using
non-volatile operations, this method is safe. However, it <em>can</em> lead to bugs at the
application level, so this method should be used with care.</p>
<h6 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">let </span><span class="kw-2">mut </span>value = <span class="number">42</span>;
<span class="kw">let </span><span class="kw-2">mut </span>volatile = Volatile::new(<span class="kw-2">&amp;mut </span>value);
volatile.write(<span class="number">50</span>);
<span class="kw">let </span>unwrapped: <span class="kw-2">&amp;mut </span>i32 = volatile.extract_inner();

<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>unwrapped, <span class="number">50</span>); <span class="comment">// non volatile access, be careful!</span></code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Volatile%3CR,+A%3E-2" class="impl"><a class="src rightside" href="../src/volatile/lib.rs.html#282-389">source</a><a href="#impl-Volatile%3CR,+A%3E-2" class="anchor">§</a><h3 class="code-header">impl&lt;R, T, A&gt; <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;R, A&gt;<div class="where">where
    R: Deref&lt;Target = T&gt;,
    T: ?Sized,</div></h3></section></summary><div class="docblock"><p>Transformation methods for accessing struct fields</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.map" class="method"><a class="src rightside" href="../src/volatile/lib.rs.html#326-336">source</a><h4 class="code-header">pub fn <a href="#method.map" class="fn">map</a>&lt;'a, F, U&gt;(&amp;'a self, f: F) -&gt; <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;&amp;'a U, A&gt;<div class="where">where
    F: FnOnce(&amp;'a T) -&gt; &amp;'a U,
    U: ?Sized,
    T: 'a,</div></h4></section></summary><div class="docblock"><p>Constructs a new <code>Volatile</code> reference by mapping the wrapped value.</p>
<p>This method is useful for accessing individual fields of volatile structs.</p>
<p>Note that this method gives temporary access to the wrapped reference, which allows
accessing the value in a non-volatile way. This is normally not what you want, so
<strong>this method should only be used for reference-to-reference transformations</strong>.</p>
<h6 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h6>
<p>Accessing a struct field:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">struct </span>Example { field_1: u32, field_2: u8, }
<span class="kw">let </span><span class="kw-2">mut </span>value = Example { field_1: <span class="number">15</span>, field_2: <span class="number">255 </span>};
<span class="kw">let </span><span class="kw-2">mut </span>volatile = Volatile::new(<span class="kw-2">&amp;mut </span>value);

<span class="comment">// construct a volatile reference to a field
</span><span class="kw">let </span>field_2 = volatile.map(|example| <span class="kw-2">&amp;</span>example.field_2);
<span class="macro">assert_eq!</span>(field_2.read(), <span class="number">255</span>);</code></pre></div>
<p>Don’t misuse this method to do a non-volatile read of the referenced value:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">let </span><span class="kw-2">mut </span>value = <span class="number">5</span>;
<span class="kw">let </span><span class="kw-2">mut </span>volatile = Volatile::new(<span class="kw-2">&amp;mut </span>value);

<span class="comment">// DON'T DO THIS:
</span><span class="kw">let </span><span class="kw-2">mut </span>readout = <span class="number">0</span>;
volatile.map(|value| {
   readout = <span class="kw-2">*</span>value; <span class="comment">// non-volatile read, might lead to bugs
   </span>value
});</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.map_mut" class="method"><a class="src rightside" href="../src/volatile/lib.rs.html#377-388">source</a><h4 class="code-header">pub fn <a href="#method.map_mut" class="fn">map_mut</a>&lt;'a, F, U&gt;(&amp;'a mut self, f: F) -&gt; <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;&amp;'a mut U, A&gt;<div class="where">where
    F: FnOnce(&amp;mut T) -&gt; &amp;mut U,
    R: DerefMut,
    U: ?Sized,
    T: 'a,</div></h4></section></summary><div class="docblock"><p>Constructs a new mutable <code>Volatile</code> reference by mapping the wrapped value.</p>
<p>This method is useful for accessing individual fields of volatile structs.</p>
<p>Note that this method gives temporary access to the wrapped reference, which allows
accessing the value in a non-volatile way. This is normally not what you want, so
<strong>this method should only be used for reference-to-reference transformations</strong>.</p>
<h6 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h6>
<p>Accessing a struct field:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">struct </span>Example { field_1: u32, field_2: u8, }
<span class="kw">let </span><span class="kw-2">mut </span>value = Example { field_1: <span class="number">15</span>, field_2: <span class="number">255 </span>};
<span class="kw">let </span><span class="kw-2">mut </span>volatile = Volatile::new(<span class="kw-2">&amp;mut </span>value);

<span class="comment">// construct a volatile reference to a field
</span><span class="kw">let </span><span class="kw-2">mut </span>field_2 = volatile.map_mut(|example| <span class="kw-2">&amp;mut </span>example.field_2);
field_2.write(<span class="number">128</span>);
<span class="macro">assert_eq!</span>(field_2.read(), <span class="number">128</span>);</code></pre></div>
<p>Don’t misuse this method to do a non-volatile read or write of the referenced value:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">let </span><span class="kw-2">mut </span>value = <span class="number">5</span>;
<span class="kw">let </span><span class="kw-2">mut </span>volatile = Volatile::new(<span class="kw-2">&amp;mut </span>value);

<span class="comment">// DON'T DO THIS:
</span>volatile.map_mut(|value| {
   <span class="kw-2">*</span>value = <span class="number">10</span>; <span class="comment">// non-volatile write, might lead to bugs
   </span>value
});</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Volatile%3CR,+A%3E-3" class="impl"><a class="src rightside" href="../src/volatile/lib.rs.html#392-643">source</a><a href="#impl-Volatile%3CR,+A%3E-3" class="anchor">§</a><h3 class="code-header">impl&lt;T, R, A&gt; <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;R, A&gt;<div class="where">where
    R: Deref&lt;Target = [T]&gt;,</div></h3></section></summary><div class="docblock"><p>Methods for volatile slices</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.index" class="method"><a class="src rightside" href="../src/volatile/lib.rs.html#428-434">source</a><h4 class="code-header">pub fn <a href="#method.index" class="fn">index</a>&lt;'a, I&gt;(&amp;'a self, index: I) -&gt; <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;&amp;'a I::Output, A&gt;<div class="where">where
    I: SliceIndex&lt;[T]&gt;,
    T: 'a,</div></h4></section></summary><div class="docblock"><p>Applies the index operation on the wrapped slice.</p>
<p>Returns a shared <code>Volatile</code> reference to the resulting subslice.</p>
<p>This is a convenience method for the <code>map(|slice| slice.index(index))</code> operation, so it
has the same behavior as the indexing operation on slice (e.g. panic if index is
out-of-bounds).</p>
<h6 id="examples-3"><a class="doc-anchor" href="#examples-3">§</a>Examples</h6>
<p>Accessing a single slice element:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">let </span>array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span>slice = <span class="kw-2">&amp;</span>array[..];
<span class="kw">let </span>volatile = Volatile::new(slice);
<span class="macro">assert_eq!</span>(volatile.index(<span class="number">1</span>).read(), <span class="number">2</span>);</code></pre></div>
<p>Accessing a subslice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">let </span>array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span>slice = <span class="kw-2">&amp;</span>array[..];
<span class="kw">let </span>volatile = Volatile::new(slice);
<span class="kw">let </span>subslice = volatile.index(<span class="number">1</span>..);
<span class="macro">assert_eq!</span>(subslice.index(<span class="number">0</span>).read(), <span class="number">2</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.index_mut" class="method"><a class="src rightside" href="../src/volatile/lib.rs.html#470-477">source</a><h4 class="code-header">pub fn <a href="#method.index_mut" class="fn">index_mut</a>&lt;'a, I&gt;(&amp;'a mut self, index: I) -&gt; <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;&amp;mut I::Output, A&gt;<div class="where">where
    I: SliceIndex&lt;[T]&gt;,
    R: DerefMut,
    T: 'a,</div></h4></section></summary><div class="docblock"><p>Applies the mutable index operation on the wrapped slice.</p>
<p>Returns a mutable <code>Volatile</code> reference to the resulting subslice.</p>
<p>This is a convenience method for the <code>map_mut(|slice| slice.index_mut(index))</code>
operation, so it has the same behavior as the indexing operation on slice
(e.g. panic if index is out-of-bounds).</p>
<h6 id="examples-4"><a class="doc-anchor" href="#examples-4">§</a>Examples</h6>
<p>Accessing a single slice element:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">let </span><span class="kw-2">mut </span>array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span>slice = <span class="kw-2">&amp;mut </span>array[..];
<span class="kw">let </span><span class="kw-2">mut </span>volatile = Volatile::new(slice);
volatile.index_mut(<span class="number">1</span>).write(<span class="number">6</span>);
<span class="macro">assert_eq!</span>(volatile.index(<span class="number">1</span>).read(), <span class="number">6</span>);</code></pre></div>
<p>Accessing a subslice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">let </span><span class="kw-2">mut </span>array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span>slice = <span class="kw-2">&amp;mut </span>array[..];
<span class="kw">let </span><span class="kw-2">mut </span>volatile = Volatile::new(slice);
<span class="kw">let </span><span class="kw-2">mut </span>subslice = volatile.index_mut(<span class="number">1</span>..);
subslice.index_mut(<span class="number">0</span>).write(<span class="number">6</span>);
<span class="macro">assert_eq!</span>(subslice.index(<span class="number">0</span>).read(), <span class="number">6</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.copy_into_slice" class="method"><a class="src rightside" href="../src/volatile/lib.rs.html#512-529">source</a><h4 class="code-header">pub fn <a href="#method.copy_into_slice" class="fn">copy_into_slice</a>(&amp;self, dst: &amp;mut [T])<div class="where">where
    T: Copy,</div></h4></section></summary><div class="docblock"><p>Copies all elements from <code>self</code> into <code>dst</code>, using a volatile memcpy.</p>
<p>The length of <code>dst</code> must be the same as <code>self</code>.</p>
<p>The method is only available with the <code>unstable</code> feature enabled (requires a nightly
Rust compiler).</p>
<h6 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h6>
<p>This function will panic if the two slices have different lengths.</p>
<h6 id="examples-5"><a class="doc-anchor" href="#examples-5">§</a>Examples</h6>
<p>Copying two elements from a volatile slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">let </span>src = [<span class="number">1</span>, <span class="number">2</span>];
<span class="comment">// the `Volatile` type does not work with arrays, so convert `src` to a slice
</span><span class="kw">let </span>slice = <span class="kw-2">&amp;</span>src[..];
<span class="kw">let </span>volatile = Volatile::new(slice);
<span class="kw">let </span><span class="kw-2">mut </span>dst = [<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>];

<span class="comment">// Because the slices have to be the same length,
// we slice the destination slice from three elements
// to two. It will panic if we don't do this.
</span>volatile.copy_into_slice(<span class="kw-2">&amp;mut </span>dst[<span class="number">1</span>..]);

<span class="macro">assert_eq!</span>(src, [<span class="number">1</span>, <span class="number">2</span>]);
<span class="macro">assert_eq!</span>(dst, [<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.copy_from_slice" class="method"><a class="src rightside" href="../src/volatile/lib.rs.html#567-585">source</a><h4 class="code-header">pub fn <a href="#method.copy_from_slice" class="fn">copy_from_slice</a>(&amp;mut self, src: &amp;[T])<div class="where">where
    T: Copy,
    R: DerefMut,</div></h4></section></summary><div class="docblock"><p>Copies all elements from <code>src</code> into <code>self</code>, using a volatile memcpy.</p>
<p>The length of <code>src</code> must be the same as <code>self</code>.</p>
<p>This method is similar to the <code>slice::copy_from_slice</code> method of the standard library. The
difference is that this method performs a volatile copy.</p>
<p>The method is only available with the <code>unstable</code> feature enabled (requires a nightly
Rust compiler).</p>
<h6 id="panics-1"><a class="doc-anchor" href="#panics-1">§</a>Panics</h6>
<p>This function will panic if the two slices have different lengths.</p>
<h6 id="examples-6"><a class="doc-anchor" href="#examples-6">§</a>Examples</h6>
<p>Copying two elements from a slice into a volatile slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">let </span>src = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];
<span class="kw">let </span><span class="kw-2">mut </span>dst = [<span class="number">0</span>, <span class="number">0</span>];
<span class="comment">// the `Volatile` type does not work with arrays, so convert `dst` to a slice
</span><span class="kw">let </span>slice = <span class="kw-2">&amp;mut </span>dst[..];
<span class="kw">let </span><span class="kw-2">mut </span>volatile = Volatile::new(slice);

<span class="comment">// Because the slices have to be the same length,
// we slice the source slice from four elements
// to two. It will panic if we don't do this.
</span>volatile.copy_from_slice(<span class="kw-2">&amp;</span>src[<span class="number">2</span>..]);

<span class="macro">assert_eq!</span>(src, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);
<span class="macro">assert_eq!</span>(dst, [<span class="number">3</span>, <span class="number">4</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.copy_within" class="method"><a class="src rightside" href="../src/volatile/lib.rs.html#620-642">source</a><h4 class="code-header">pub fn <a href="#method.copy_within" class="fn">copy_within</a>(&amp;mut self, src: impl RangeBounds&lt;usize&gt;, dest: usize)<div class="where">where
    T: Copy,
    R: DerefMut,</div></h4></section></summary><div class="docblock"><p>Copies elements from one part of the slice to another part of itself, using a
volatile <code>memmove</code>.</p>
<p><code>src</code> is the range within <code>self</code> to copy from. <code>dest</code> is the starting index of the
range within <code>self</code> to copy to, which will have the same length as <code>src</code>. The two ranges
may overlap. The ends of the two ranges must be less than or equal to <code>self.len()</code>.</p>
<p>This method is similar to the <code>slice::copy_within</code> method of the standard library. The
difference is that this method performs a volatile copy.</p>
<p>This method is only available with the <code>unstable</code> feature enabled (requires a nightly
Rust compiler).</p>
<h6 id="panics-2"><a class="doc-anchor" href="#panics-2">§</a>Panics</h6>
<p>This function will panic if either range exceeds the end of the slice, or if the end
of <code>src</code> is before the start.</p>
<h6 id="examples-7"><a class="doc-anchor" href="#examples-7">§</a>Examples</h6>
<p>Copying four bytes within a slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">let </span><span class="kw-2">mut </span>byte_array = <span class="kw-2">*</span><span class="string">b"Hello, World!"</span>;
<span class="kw">let </span><span class="kw-2">mut </span>slice: <span class="kw-2">&amp;mut </span>[u8] = <span class="kw-2">&amp;mut </span>byte_array[..];
<span class="kw">let </span><span class="kw-2">mut </span>volatile = Volatile::new(slice);

volatile.copy_within(<span class="number">1</span>..<span class="number">5</span>, <span class="number">8</span>);

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>byte_array, <span class="string">b"Hello, Wello!"</span>);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Volatile%3CR,+A%3E-4" class="impl"><a class="src rightside" href="../src/volatile/lib.rs.html#646-679">source</a><a href="#impl-Volatile%3CR,+A%3E-4" class="anchor">§</a><h3 class="code-header">impl&lt;R, A&gt; <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;R, A&gt;<div class="where">where
    R: Deref&lt;Target = [u8]&gt;,</div></h3></section></summary><div class="docblock"><p>Methods for volatile byte slices</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fill" class="method"><a class="src rightside" href="../src/volatile/lib.rs.html#670-678">source</a><h4 class="code-header">pub fn <a href="#method.fill" class="fn">fill</a>(&amp;mut self, value: u8)<div class="where">where
    R: DerefMut,</div></h4></section></summary><div class="docblock"><p>Sets all elements of the byte slice to the given <code>value</code> using a volatile <code>memset</code>.</p>
<p>This method is similar to the <code>slice::fill</code> method of the standard library, with the
difference that this method performs a volatile write operation. Another difference
is that this method is only available for byte slices (not general <code>&amp;mut [T]</code> slices)
because there currently isn’t a instrinsic function that allows non-<code>u8</code> values.</p>
<p>This method is only available with the <code>unstable</code> feature enabled (requires a nightly
Rust compiler).</p>
<h6 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">let </span><span class="kw-2">mut </span>buf = Volatile::new(<span class="macro">vec!</span>[<span class="number">0</span>; <span class="number">10</span>]);
buf.fill(<span class="number">1</span>);
<span class="macro">assert_eq!</span>(buf.extract_inner(), <span class="macro">vec!</span>[<span class="number">1</span>; <span class="number">10</span>]);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Volatile%3CR,+A%3E-5" class="impl"><a class="src rightside" href="../src/volatile/lib.rs.html#682-739">source</a><a href="#impl-Volatile%3CR,+A%3E-5" class="anchor">§</a><h3 class="code-header">impl&lt;R, A, T, const N: usize&gt; <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;R, A&gt;<div class="where">where
    R: Deref&lt;Target = [T; N]&gt;,</div></h3></section></summary><div class="docblock"><p>Methods for converting arrays to slices</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_slice" class="method"><a class="src rightside" href="../src/volatile/lib.rs.html#708-710">source</a><h4 class="code-header">pub fn <a href="#method.as_slice" class="fn">as_slice</a>(&amp;self) -&gt; <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;&amp;[T], A&gt;</h4></section></summary><div class="docblock"><p>Converts an array reference to a shared slice.</p>
<p>This makes it possible to use the methods defined on slices.</p>
<h6 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h6>
<p>Reading a subslice from a volatile array reference using <code>index</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">let </span>src = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];
<span class="kw">let </span>volatile = Volatile::new(<span class="kw-2">&amp;</span>src);

<span class="comment">// convert the `Volatile&lt;&amp;[i32; 4]&gt;` array reference to a `Volatile&lt;&amp;[i32]&gt;` slice
</span><span class="kw">let </span>volatile_slice = volatile.as_slice();
<span class="comment">// we can now use the slice methods
</span><span class="kw">let </span>subslice = volatile_slice.index(<span class="number">2</span>..);

<span class="macro">assert_eq!</span>(subslice.index(<span class="number">0</span>).read(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(subslice.index(<span class="number">1</span>).read(), <span class="number">4</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut_slice" class="method"><a class="src rightside" href="../src/volatile/lib.rs.html#733-738">source</a><h4 class="code-header">pub fn <a href="#method.as_mut_slice" class="fn">as_mut_slice</a>(&amp;mut self) -&gt; <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;&amp;mut [T], A&gt;<div class="where">where
    R: DerefMut,</div></h4></section></summary><div class="docblock"><p>Converts a mutable array reference to a mutable slice.</p>
<p>This makes it possible to use the methods defined on slices.</p>
<h6 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h6>
<p>Writing to an index of a mutable array reference:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">let </span><span class="kw-2">mut </span>dst = [<span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let </span><span class="kw-2">mut </span>volatile = Volatile::new(<span class="kw-2">&amp;mut </span>dst);

<span class="comment">// convert the `Volatile&lt;&amp;mut [i32; 2]&gt;` array reference to a `Volatile&lt;&amp;mut [i32]&gt;` slice
</span><span class="kw">let </span><span class="kw-2">mut </span>volatile_slice = volatile.as_mut_slice();
<span class="comment">// we can now use the slice methods
</span>volatile_slice.index_mut(<span class="number">1</span>).write(<span class="number">1</span>);

<span class="macro">assert_eq!</span>(dst, [<span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Volatile%3CR%3E-1" class="impl"><a class="src rightside" href="../src/volatile/lib.rs.html#742-788">source</a><a href="#impl-Volatile%3CR%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;R&gt;</h3></section></summary><div class="docblock"><p>Methods for restricting access.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.read_only" class="method"><a class="src rightside" href="../src/volatile/lib.rs.html#757-762">source</a><h4 class="code-header">pub fn <a href="#method.read_only" class="fn">read_only</a>(self) -&gt; <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;R, <a class="struct" href="access/struct.ReadOnly.html" title="struct volatile::access::ReadOnly">ReadOnly</a>&gt;</h4></section></summary><div class="docblock"><p>Restricts access permissions to read-only.</p>
<h6 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">let </span><span class="kw-2">mut </span>value: i16 = -<span class="number">4</span>;
<span class="kw">let </span><span class="kw-2">mut </span>volatile = Volatile::new(<span class="kw-2">&amp;mut </span>value);

<span class="kw">let </span>read_only = volatile.read_only();
<span class="macro">assert_eq!</span>(read_only.read(), -<span class="number">4</span>);
<span class="comment">// read_only.write(10); // compile-time error</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_only" class="method"><a class="src rightside" href="../src/volatile/lib.rs.html#782-787">source</a><h4 class="code-header">pub fn <a href="#method.write_only" class="fn">write_only</a>(self) -&gt; <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;R, <a class="struct" href="access/struct.WriteOnly.html" title="struct volatile::access::WriteOnly">WriteOnly</a>&gt;</h4></section></summary><div class="docblock"><p>Restricts access permissions to write-only.</p>
<h6 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h6>
<p>Creating a write-only reference to a struct field:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>volatile::Volatile;

<span class="kw">struct </span>Example { field_1: u32, field_2: u8, }
<span class="kw">let </span><span class="kw-2">mut </span>value = Example { field_1: <span class="number">15</span>, field_2: <span class="number">255 </span>};
<span class="kw">let </span><span class="kw-2">mut </span>volatile = Volatile::new(<span class="kw-2">&amp;mut </span>value);

<span class="comment">// construct a volatile write-only reference to `field_2`
</span><span class="kw">let </span><span class="kw-2">mut </span>field_2 = volatile.map_mut(|example| <span class="kw-2">&amp;mut </span>example.field_2).write_only();
field_2.write(<span class="number">14</span>);
<span class="comment">// field_2.read(); // compile-time error</span></code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Volatile%3CR,+A%3E" class="impl"><a class="src rightside" href="../src/volatile/lib.rs.html#45">source</a><a href="#impl-Clone-for-Volatile%3CR,+A%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R: Clone, A: Clone&gt; Clone for <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;R, A&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../src/volatile/lib.rs.html#45">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;R, A&gt;</h4></section></summary><div class='docblock'>Returns a copy of the value. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="since rightside" title="Stable since Rust version 1.0.0">1.0.0</span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Volatile%3CR,+A%3E" class="impl"><a class="src rightside" href="../src/volatile/lib.rs.html#790-799">source</a><a href="#impl-Debug-for-Volatile%3CR,+A%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R, T, A&gt; Debug for <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;R, A&gt;<div class="where">where
    R: Deref&lt;Target = T&gt;,
    T: Copy + Debug,
    A: <a class="trait" href="access/trait.Readable.html" title="trait volatile::access::Readable">Readable</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl"><a class="src rightside" href="../src/volatile/lib.rs.html#796-798">source</a><a href="#method.fmt-1" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fmt</a>(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Volatile%3CR,+WriteOnly%3E" class="impl"><a class="src rightside" href="../src/volatile/lib.rs.html#801-808">source</a><a href="#impl-Debug-for-Volatile%3CR,+WriteOnly%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R&gt; Debug for <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;R, <a class="struct" href="access/struct.WriteOnly.html" title="struct volatile::access::WriteOnly">WriteOnly</a>&gt;<div class="where">where
    R: Deref,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/volatile/lib.rs.html#805-807">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a class="fn">fmt</a>(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a>Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Volatile%3CR,+A%3E" class="impl"><a href="#impl-Freeze-for-Volatile%3CR,+A%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R, A&gt; Freeze for <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;R, A&gt;<div class="where">where
    R: Freeze,</div></h3></section><section id="impl-RefUnwindSafe-for-Volatile%3CR,+A%3E" class="impl"><a href="#impl-RefUnwindSafe-for-Volatile%3CR,+A%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R, A&gt; RefUnwindSafe for <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;R, A&gt;<div class="where">where
    R: RefUnwindSafe,
    A: RefUnwindSafe,</div></h3></section><section id="impl-Send-for-Volatile%3CR,+A%3E" class="impl"><a href="#impl-Send-for-Volatile%3CR,+A%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R, A&gt; Send for <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;R, A&gt;<div class="where">where
    R: Send,
    A: Send,</div></h3></section><section id="impl-Sync-for-Volatile%3CR,+A%3E" class="impl"><a href="#impl-Sync-for-Volatile%3CR,+A%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R, A&gt; Sync for <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;R, A&gt;<div class="where">where
    R: Sync,
    A: Sync,</div></h3></section><section id="impl-Unpin-for-Volatile%3CR,+A%3E" class="impl"><a href="#impl-Unpin-for-Volatile%3CR,+A%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R, A&gt; Unpin for <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;R, A&gt;<div class="where">where
    R: Unpin,
    A: Unpin,</div></h3></section><section id="impl-UnwindSafe-for-Volatile%3CR,+A%3E" class="impl"><a href="#impl-UnwindSafe-for-Volatile%3CR,+A%3E" class="anchor">§</a><h3 class="code-header">impl&lt;R, A&gt; UnwindSafe for <a class="struct" href="struct.Volatile.html" title="struct volatile::Volatile">Volatile</a>&lt;R, A&gt;<div class="where">where
    R: UnwindSafe,
    A: UnwindSafe,</div></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Any for T<div class="where">where
    T: 'static + ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a class="fn">type_id</a>(&amp;self) -&gt; TypeId</h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Borrow&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow</a>(&amp;self) -&gt; &amp;T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; BorrowMut&lt;T&gt; for T<div class="where">where
    T: ?Sized,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a class="fn">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; From&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; Into&lt;U&gt; for T<div class="where">where
    U: From&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code>[From]&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryFrom&lt;U&gt; for T<div class="where">where
    U: Into&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = Infallible</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_from</a>(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; TryInto&lt;U&gt; for T<div class="where">where
    U: TryFrom&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Error</a> = &lt;U as TryFrom&lt;T&gt;&gt;::Error</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a class="fn">try_into</a>(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>