(function() {var type_impls = {
"ktest":[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-String\" class=\"impl\"><a href=\"#impl-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.new\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0, const since 1.39.0\">1.0.0 (const: 1.39.0)</span><h4 class=\"code-header\">pub const fn <a class=\"fn\">new</a>() -&gt; String</h4></section></summary><div class=\"docblock\"><p>Creates a new empty <code>String</code>.</p>\n<p>Given that the <code>String</code> is empty, this will not allocate any initial\nbuffer. While that means that this initial operation is very\ninexpensive, it may cause excessive allocation later when you add\ndata. If you have an idea of how much data the <code>String</code> will hold,\nconsider the <a href=\"String::with_capacity\"><code>with_capacity</code></a> method to prevent excessive\nre-allocation.</p>\n<h5 id=\"examples\"><a href=\"#examples\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = String::new();</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.with_capacity\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">with_capacity</a>(capacity: usize) -&gt; String</h4></section></summary><div class=\"docblock\"><p>Creates a new empty <code>String</code> with at least the specified capacity.</p>\n<p><code>String</code>s have an internal buffer to hold their data. The capacity is\nthe length of that buffer, and can be queried with the <a href=\"String::capacity\"><code>capacity</code></a>\nmethod. This method creates an empty <code>String</code>, but one with an initial\nbuffer that can hold at least <code>capacity</code> bytes. This is useful when you\nmay be appending a bunch of data to the <code>String</code>, reducing the number of\nreallocations it needs to do.</p>\n<p>If the given capacity is <code>0</code>, no allocation will occur, and this method\nis identical to the <a href=\"String::new\"><code>new</code></a> method.</p>\n<h5 id=\"examples-1\"><a href=\"#examples-1\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::with_capacity(<span class=\"number\">10</span>);\n\n<span class=\"comment\">// The String contains no chars, even though it has capacity for more\n</span><span class=\"macro\">assert_eq!</span>(s.len(), <span class=\"number\">0</span>);\n\n<span class=\"comment\">// These are all done without reallocating...\n</span><span class=\"kw\">let </span>cap = s.capacity();\n<span class=\"kw\">for _ in </span><span class=\"number\">0</span>..<span class=\"number\">10 </span>{\n    s.push(<span class=\"string\">'a'</span>);\n}\n\n<span class=\"macro\">assert_eq!</span>(s.capacity(), cap);\n\n<span class=\"comment\">// ...but this may make the string reallocate\n</span>s.push(<span class=\"string\">'a'</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_utf8\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">from_utf8</a>(vec: Vec&lt;u8&gt;) -&gt; Result&lt;String, FromUtf8Error&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a vector of bytes to a <code>String</code>.</p>\n<p>A string ([<code>String</code>]) is made of bytes ([<code>u8</code>]), and a vector of bytes\n(<a href=\"crate::vec::Vec\" title=\"Vec\"><code>Vec&lt;u8&gt;</code></a>) is made of bytes, so this function converts between the\ntwo. Not all byte slices are valid <code>String</code>s, however: <code>String</code>\nrequires that it is valid UTF-8. <code>from_utf8()</code> checks to ensure that\nthe bytes are valid UTF-8, and then does the conversion.</p>\n<p>If you are sure that the byte slice is valid UTF-8, and you don‚Äôt want\nto incur the overhead of the validity check, there is an unsafe version\nof this function, <a href=\"String::from_utf8_unchecked\"><code>from_utf8_unchecked</code></a>, which has the same behavior\nbut skips the check.</p>\n<p>This method will take care to not copy the vector, for efficiency‚Äôs\nsake.</p>\n<p>If you need a <a href=\"prim@str\" title=\"&amp;str\"><code>&amp;str</code></a> instead of a <code>String</code>, consider\n[<code>str::from_utf8</code>].</p>\n<p>The inverse of this method is <a href=\"String::into_bytes\"><code>into_bytes</code></a>.</p>\n<h5 id=\"errors\"><a href=\"#errors\">Errors</a></h5>\n<p>Returns [<code>Err</code>] if the slice is not UTF-8 with a description as to why the\nprovided bytes are not UTF-8. The vector you moved in is also included.</p>\n<h5 id=\"examples-2\"><a href=\"#examples-2\">Examples</a></h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// some bytes, in a vector\n</span><span class=\"kw\">let </span>sparkle_heart = <span class=\"macro\">vec!</span>[<span class=\"number\">240</span>, <span class=\"number\">159</span>, <span class=\"number\">146</span>, <span class=\"number\">150</span>];\n\n<span class=\"comment\">// We know these bytes are valid, so we'll use `unwrap()`.\n</span><span class=\"kw\">let </span>sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"üíñ\"</span>, sparkle_heart);</code></pre></div>\n<p>Incorrect bytes:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// some invalid bytes, in a vector\n</span><span class=\"kw\">let </span>sparkle_heart = <span class=\"macro\">vec!</span>[<span class=\"number\">0</span>, <span class=\"number\">159</span>, <span class=\"number\">146</span>, <span class=\"number\">150</span>];\n\n<span class=\"macro\">assert!</span>(String::from_utf8(sparkle_heart).is_err());</code></pre></div>\n<p>See the docs for [<code>FromUtf8Error</code>] for more details on what you can do\nwith this error.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_utf8_lossy\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">from_utf8_lossy</a>(v: &amp;[u8]) -&gt; Cow&lt;'_, str&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a slice of bytes to a string, including invalid characters.</p>\n<p>Strings are made of bytes ([<code>u8</code>]), and a slice of bytes\n(<a href=\"prim@slice\"><code>&amp;[u8]</code></a>) is made of bytes, so this function converts\nbetween the two. Not all byte slices are valid strings, however: strings\nare required to be valid UTF-8. During this conversion,\n<code>from_utf8_lossy()</code> will replace any invalid UTF-8 sequences with\n<a href=\"core::char::REPLACEMENT_CHARACTER\"><code>U+FFFD REPLACEMENT CHARACTER</code></a>, which looks like this: ÔøΩ</p>\n<p>If you are sure that the byte slice is valid UTF-8, and you don‚Äôt want\nto incur the overhead of the conversion, there is an unsafe version\nof this function, <a href=\"String::from_utf8_unchecked\"><code>from_utf8_unchecked</code></a>, which has the same behavior\nbut skips the checks.</p>\n<p>This function returns a <a href=\"crate::borrow::Cow\" title=\"borrow::Cow\"><code>Cow&lt;'a, str&gt;</code></a>. If our byte slice is invalid\nUTF-8, then we need to insert the replacement characters, which will\nchange the size of the string, and hence, require a <code>String</code>. But if\nit‚Äôs already valid UTF-8, we don‚Äôt need a new allocation. This return\ntype allows us to handle both cases.</p>\n<h5 id=\"examples-3\"><a href=\"#examples-3\">Examples</a></h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// some bytes, in a vector\n</span><span class=\"kw\">let </span>sparkle_heart = <span class=\"macro\">vec!</span>[<span class=\"number\">240</span>, <span class=\"number\">159</span>, <span class=\"number\">146</span>, <span class=\"number\">150</span>];\n\n<span class=\"kw\">let </span>sparkle_heart = String::from_utf8_lossy(<span class=\"kw-2\">&amp;</span>sparkle_heart);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"üíñ\"</span>, sparkle_heart);</code></pre></div>\n<p>Incorrect bytes:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// some invalid bytes\n</span><span class=\"kw\">let </span>input = <span class=\"string\">b\"Hello \\xF0\\x90\\x80World\"</span>;\n<span class=\"kw\">let </span>output = String::from_utf8_lossy(input);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"Hello ÔøΩWorld\"</span>, output);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_utf16\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">from_utf16</a>(v: &amp;[u16]) -&gt; Result&lt;String, FromUtf16Error&gt;</h4></section></summary><div class=\"docblock\"><p>Decode a UTF-16‚Äìencoded vector <code>v</code> into a <code>String</code>, returning [<code>Err</code>]\nif <code>v</code> contains any invalid data.</p>\n<h5 id=\"examples-4\"><a href=\"#examples-4\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// ùÑûmusic\n</span><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0xD834</span>, <span class=\"number\">0xDD1E</span>, <span class=\"number\">0x006d</span>, <span class=\"number\">0x0075</span>,\n          <span class=\"number\">0x0073</span>, <span class=\"number\">0x0069</span>, <span class=\"number\">0x0063</span>];\n<span class=\"macro\">assert_eq!</span>(String::from(<span class=\"string\">\"ùÑûmusic\"</span>),\n           String::from_utf16(v).unwrap());\n\n<span class=\"comment\">// ùÑûmu&lt;invalid&gt;ic\n</span><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0xD834</span>, <span class=\"number\">0xDD1E</span>, <span class=\"number\">0x006d</span>, <span class=\"number\">0x0075</span>,\n          <span class=\"number\">0xD800</span>, <span class=\"number\">0x0069</span>, <span class=\"number\">0x0063</span>];\n<span class=\"macro\">assert!</span>(String::from_utf16(v).is_err());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_utf16_lossy\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">from_utf16_lossy</a>(v: &amp;[u16]) -&gt; String</h4></section></summary><div class=\"docblock\"><p>Decode a UTF-16‚Äìencoded slice <code>v</code> into a <code>String</code>, replacing\ninvalid data with <a href=\"core::char::REPLACEMENT_CHARACTER\">the replacement character (<code>U+FFFD</code>)</a>.</p>\n<p>Unlike <a href=\"String::from_utf8_lossy\"><code>from_utf8_lossy</code></a> which returns a <a href=\"crate::borrow::Cow\" title=\"borrow::Cow\"><code>Cow&lt;'a, str&gt;</code></a>,\n<code>from_utf16_lossy</code> returns a <code>String</code> since the UTF-16 to UTF-8\nconversion requires a memory allocation.</p>\n<h5 id=\"examples-5\"><a href=\"#examples-5\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// ùÑûmus&lt;invalid&gt;ic&lt;invalid&gt;\n</span><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0xD834</span>, <span class=\"number\">0xDD1E</span>, <span class=\"number\">0x006d</span>, <span class=\"number\">0x0075</span>,\n          <span class=\"number\">0x0073</span>, <span class=\"number\">0xDD1E</span>, <span class=\"number\">0x0069</span>, <span class=\"number\">0x0063</span>,\n          <span class=\"number\">0xD834</span>];\n\n<span class=\"macro\">assert_eq!</span>(String::from(<span class=\"string\">\"ùÑûmus\\u{FFFD}ic\\u{FFFD}\"</span>),\n           String::from_utf16_lossy(v));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_utf16le\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">from_utf16le</a>(v: &amp;[u8]) -&gt; Result&lt;String, FromUtf16Error&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>str_from_utf16_endian</code>)</span></div></span></summary><div class=\"docblock\"><p>Decode a UTF-16LE‚Äìencoded vector <code>v</code> into a <code>String</code>, returning [<code>Err</code>]\nif <code>v</code> contains any invalid data.</p>\n<h5 id=\"examples-6\"><a href=\"#examples-6\">Examples</a></h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(str_from_utf16_endian)]\n</span><span class=\"comment\">// ùÑûmusic\n</span><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0x34</span>, <span class=\"number\">0xD8</span>, <span class=\"number\">0x1E</span>, <span class=\"number\">0xDD</span>, <span class=\"number\">0x6d</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x75</span>, <span class=\"number\">0x00</span>,\n          <span class=\"number\">0x73</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x69</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x63</span>, <span class=\"number\">0x00</span>];\n<span class=\"macro\">assert_eq!</span>(String::from(<span class=\"string\">\"ùÑûmusic\"</span>),\n           String::from_utf16le(v).unwrap());\n\n<span class=\"comment\">// ùÑûmu&lt;invalid&gt;ic\n</span><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0x34</span>, <span class=\"number\">0xD8</span>, <span class=\"number\">0x1E</span>, <span class=\"number\">0xDD</span>, <span class=\"number\">0x6d</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x75</span>, <span class=\"number\">0x00</span>,\n          <span class=\"number\">0x00</span>, <span class=\"number\">0xD8</span>, <span class=\"number\">0x69</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x63</span>, <span class=\"number\">0x00</span>];\n<span class=\"macro\">assert!</span>(String::from_utf16le(v).is_err());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_utf16le_lossy\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">from_utf16le_lossy</a>(v: &amp;[u8]) -&gt; String</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>str_from_utf16_endian</code>)</span></div></span></summary><div class=\"docblock\"><p>Decode a UTF-16LE‚Äìencoded slice <code>v</code> into a <code>String</code>, replacing\ninvalid data with <a href=\"core::char::REPLACEMENT_CHARACTER\">the replacement character (<code>U+FFFD</code>)</a>.</p>\n<p>Unlike <a href=\"String::from_utf8_lossy\"><code>from_utf8_lossy</code></a> which returns a <a href=\"crate::borrow::Cow\" title=\"borrow::Cow\"><code>Cow&lt;'a, str&gt;</code></a>,\n<code>from_utf16le_lossy</code> returns a <code>String</code> since the UTF-16 to UTF-8\nconversion requires a memory allocation.</p>\n<h5 id=\"examples-7\"><a href=\"#examples-7\">Examples</a></h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(str_from_utf16_endian)]\n</span><span class=\"comment\">// ùÑûmus&lt;invalid&gt;ic&lt;invalid&gt;\n</span><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0x34</span>, <span class=\"number\">0xD8</span>, <span class=\"number\">0x1E</span>, <span class=\"number\">0xDD</span>, <span class=\"number\">0x6d</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x75</span>, <span class=\"number\">0x00</span>,\n          <span class=\"number\">0x73</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x1E</span>, <span class=\"number\">0xDD</span>, <span class=\"number\">0x69</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x63</span>, <span class=\"number\">0x00</span>,\n          <span class=\"number\">0x34</span>, <span class=\"number\">0xD8</span>];\n\n<span class=\"macro\">assert_eq!</span>(String::from(<span class=\"string\">\"ùÑûmus\\u{FFFD}ic\\u{FFFD}\"</span>),\n           String::from_utf16le_lossy(v));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_utf16be\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">from_utf16be</a>(v: &amp;[u8]) -&gt; Result&lt;String, FromUtf16Error&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>str_from_utf16_endian</code>)</span></div></span></summary><div class=\"docblock\"><p>Decode a UTF-16BE‚Äìencoded vector <code>v</code> into a <code>String</code>, returning [<code>Err</code>]\nif <code>v</code> contains any invalid data.</p>\n<h5 id=\"examples-8\"><a href=\"#examples-8\">Examples</a></h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(str_from_utf16_endian)]\n</span><span class=\"comment\">// ùÑûmusic\n</span><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0xD8</span>, <span class=\"number\">0x34</span>, <span class=\"number\">0xDD</span>, <span class=\"number\">0x1E</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x6d</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x75</span>,\n          <span class=\"number\">0x00</span>, <span class=\"number\">0x73</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x69</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x63</span>];\n<span class=\"macro\">assert_eq!</span>(String::from(<span class=\"string\">\"ùÑûmusic\"</span>),\n           String::from_utf16be(v).unwrap());\n\n<span class=\"comment\">// ùÑûmu&lt;invalid&gt;ic\n</span><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0xD8</span>, <span class=\"number\">0x34</span>, <span class=\"number\">0xDD</span>, <span class=\"number\">0x1E</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x6d</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x75</span>,\n          <span class=\"number\">0xD8</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x69</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x63</span>];\n<span class=\"macro\">assert!</span>(String::from_utf16be(v).is_err());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_utf16be_lossy\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">from_utf16be_lossy</a>(v: &amp;[u8]) -&gt; String</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>str_from_utf16_endian</code>)</span></div></span></summary><div class=\"docblock\"><p>Decode a UTF-16BE‚Äìencoded slice <code>v</code> into a <code>String</code>, replacing\ninvalid data with <a href=\"core::char::REPLACEMENT_CHARACTER\">the replacement character (<code>U+FFFD</code>)</a>.</p>\n<p>Unlike <a href=\"String::from_utf8_lossy\"><code>from_utf8_lossy</code></a> which returns a <a href=\"crate::borrow::Cow\" title=\"borrow::Cow\"><code>Cow&lt;'a, str&gt;</code></a>,\n<code>from_utf16le_lossy</code> returns a <code>String</code> since the UTF-16 to UTF-8\nconversion requires a memory allocation.</p>\n<h5 id=\"examples-9\"><a href=\"#examples-9\">Examples</a></h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(str_from_utf16_endian)]\n</span><span class=\"comment\">// ùÑûmus&lt;invalid&gt;ic&lt;invalid&gt;\n</span><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0xD8</span>, <span class=\"number\">0x34</span>, <span class=\"number\">0xDD</span>, <span class=\"number\">0x1E</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x6d</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x75</span>,\n          <span class=\"number\">0x00</span>, <span class=\"number\">0x73</span>, <span class=\"number\">0xDD</span>, <span class=\"number\">0x1E</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x69</span>, <span class=\"number\">0x00</span>, <span class=\"number\">0x63</span>,\n          <span class=\"number\">0xD8</span>, <span class=\"number\">0x34</span>];\n\n<span class=\"macro\">assert_eq!</span>(String::from(<span class=\"string\">\"ùÑûmus\\u{FFFD}ic\\u{FFFD}\"</span>),\n           String::from_utf16be_lossy(v));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.into_raw_parts\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">into_raw_parts</a>(self) -&gt; (*mut u8, usize, usize)</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>vec_into_raw_parts</code>)</span></div></span></summary><div class=\"docblock\"><p>Decomposes a <code>String</code> into its raw components.</p>\n<p>Returns the raw pointer to the underlying data, the length of\nthe string (in bytes), and the allocated capacity of the data\n(in bytes). These are the same arguments in the same order as\nthe arguments to <a href=\"String::from_raw_parts\"><code>from_raw_parts</code></a>.</p>\n<p>After calling this function, the caller is responsible for the\nmemory previously managed by the <code>String</code>. The only way to do\nthis is to convert the raw pointer, length, and capacity back\ninto a <code>String</code> with the <a href=\"String::from_raw_parts\"><code>from_raw_parts</code></a> function, allowing\nthe destructor to perform the cleanup.</p>\n<h5 id=\"examples-10\"><a href=\"#examples-10\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(vec_into_raw_parts)]\n</span><span class=\"kw\">let </span>s = String::from(<span class=\"string\">\"hello\"</span>);\n\n<span class=\"kw\">let </span>(ptr, len, cap) = s.into_raw_parts();\n\n<span class=\"kw\">let </span>rebuilt = <span class=\"kw\">unsafe </span>{ String::from_raw_parts(ptr, len, cap) };\n<span class=\"macro\">assert_eq!</span>(rebuilt, <span class=\"string\">\"hello\"</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_raw_parts\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub unsafe fn <a class=\"fn\">from_raw_parts</a>(\n    buf: *mut u8,\n    length: usize,\n    capacity: usize\n) -&gt; String</h4></section></summary><div class=\"docblock\"><p>Creates a new <code>String</code> from a length, capacity, and pointer.</p>\n<h5 id=\"safety\"><a href=\"#safety\">Safety</a></h5>\n<p>This is highly unsafe, due to the number of invariants that aren‚Äôt\nchecked:</p>\n<ul>\n<li>The memory at <code>buf</code> needs to have been previously allocated by the\nsame allocator the standard library uses, with a required alignment of exactly 1.</li>\n<li><code>length</code> needs to be less than or equal to <code>capacity</code>.</li>\n<li><code>capacity</code> needs to be the correct value.</li>\n<li>The first <code>length</code> bytes at <code>buf</code> need to be valid UTF-8.</li>\n</ul>\n<p>Violating these may cause problems like corrupting the allocator‚Äôs\ninternal data structures. For example, it is normally <strong>not</strong> safe to\nbuild a <code>String</code> from a pointer to a C <code>char</code> array containing UTF-8\n<em>unless</em> you are certain that array was originally allocated by the\nRust standard library‚Äôs allocator.</p>\n<p>The ownership of <code>buf</code> is effectively transferred to the\n<code>String</code> which may then deallocate, reallocate or change the\ncontents of memory pointed to by the pointer at will. Ensure\nthat nothing else uses the pointer after calling this\nfunction.</p>\n<h5 id=\"examples-11\"><a href=\"#examples-11\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::mem;\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>s = String::from(<span class=\"string\">\"hello\"</span>);\n\n    <span class=\"comment\">// Prevent automatically dropping the String's data\n    </span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = mem::ManuallyDrop::new(s);\n\n    <span class=\"kw\">let </span>ptr = s.as_mut_ptr();\n    <span class=\"kw\">let </span>len = s.len();\n    <span class=\"kw\">let </span>capacity = s.capacity();\n\n    <span class=\"kw\">let </span>s = String::from_raw_parts(ptr, len, capacity);\n\n    <span class=\"macro\">assert_eq!</span>(String::from(<span class=\"string\">\"hello\"</span>), s);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_utf8_unchecked\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub unsafe fn <a class=\"fn\">from_utf8_unchecked</a>(bytes: Vec&lt;u8&gt;) -&gt; String</h4></section></summary><div class=\"docblock\"><p>Converts a vector of bytes to a <code>String</code> without checking that the\nstring contains valid UTF-8.</p>\n<p>See the safe version, <a href=\"String::from_utf8\"><code>from_utf8</code></a>, for more details.</p>\n<h5 id=\"safety-1\"><a href=\"#safety-1\">Safety</a></h5>\n<p>This function is unsafe because it does not check that the bytes passed\nto it are valid UTF-8. If this constraint is violated, it may cause\nmemory unsafety issues with future users of the <code>String</code>, as the rest of\nthe standard library assumes that <code>String</code>s are valid UTF-8.</p>\n<h5 id=\"examples-12\"><a href=\"#examples-12\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// some bytes, in a vector\n</span><span class=\"kw\">let </span>sparkle_heart = <span class=\"macro\">vec!</span>[<span class=\"number\">240</span>, <span class=\"number\">159</span>, <span class=\"number\">146</span>, <span class=\"number\">150</span>];\n\n<span class=\"kw\">let </span>sparkle_heart = <span class=\"kw\">unsafe </span>{\n    String::from_utf8_unchecked(sparkle_heart)\n};\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"üíñ\"</span>, sparkle_heart);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.into_bytes\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">into_bytes</a>(self) -&gt; Vec&lt;u8&gt;</h4></section></summary><div class=\"docblock\"><p>Converts a <code>String</code> into a byte vector.</p>\n<p>This consumes the <code>String</code>, so we do not need to copy its contents.</p>\n<h5 id=\"examples-13\"><a href=\"#examples-13\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = String::from(<span class=\"string\">\"hello\"</span>);\n<span class=\"kw\">let </span>bytes = s.into_bytes();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">104</span>, <span class=\"number\">101</span>, <span class=\"number\">108</span>, <span class=\"number\">108</span>, <span class=\"number\">111</span>][..], <span class=\"kw-2\">&amp;</span>bytes[..]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_str\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.7.0\">1.7.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">as_str</a>(&amp;self) -&gt; &amp;str</h4></section></summary><div class=\"docblock\"><p>Extracts a string slice containing the entire <code>String</code>.</p>\n<h5 id=\"examples-14\"><a href=\"#examples-14\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = String::from(<span class=\"string\">\"foo\"</span>);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"foo\"</span>, s.as_str());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_mut_str\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.7.0\">1.7.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">as_mut_str</a>(&amp;mut self) -&gt; &amp;mut str</h4></section></summary><div class=\"docblock\"><p>Converts a <code>String</code> into a mutable string slice.</p>\n<h5 id=\"examples-15\"><a href=\"#examples-15\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"foobar\"</span>);\n<span class=\"kw\">let </span>s_mut_str = s.as_mut_str();\n\ns_mut_str.make_ascii_uppercase();\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"FOOBAR\"</span>, s_mut_str);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.push_str\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">push_str</a>(&amp;mut self, string: &amp;str)</h4></section></summary><div class=\"docblock\"><p>Appends a given string slice onto the end of this <code>String</code>.</p>\n<h5 id=\"examples-16\"><a href=\"#examples-16\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"foo\"</span>);\n\ns.push_str(<span class=\"string\">\"bar\"</span>);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"foobar\"</span>, s);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.extend_from_within\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">extend_from_within</a>&lt;R&gt;(&amp;mut self, src: R)<div class=\"where\">where\n    R: RangeBounds&lt;usize&gt;,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>string_extend_from_within</code>)</span></div></span></summary><div class=\"docblock\"><p>Copies elements from <code>src</code> range to the end of the string.</p>\n<h5 id=\"panics\"><a href=\"#panics\">Panics</a></h5>\n<p>Panics if the starting point or end point do not lie on a [<code>char</code>]\nboundary, or if they‚Äôre out of bounds.</p>\n<h5 id=\"examples-17\"><a href=\"#examples-17\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(string_extend_from_within)]\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>string = String::from(<span class=\"string\">\"abcde\"</span>);\n\nstring.extend_from_within(<span class=\"number\">2</span>..);\n<span class=\"macro\">assert_eq!</span>(string, <span class=\"string\">\"abcdecde\"</span>);\n\nstring.extend_from_within(..<span class=\"number\">2</span>);\n<span class=\"macro\">assert_eq!</span>(string, <span class=\"string\">\"abcdecdeab\"</span>);\n\nstring.extend_from_within(<span class=\"number\">4</span>..<span class=\"number\">8</span>);\n<span class=\"macro\">assert_eq!</span>(string, <span class=\"string\">\"abcdecdeabecde\"</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.capacity\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">capacity</a>(&amp;self) -&gt; usize</h4></section></summary><div class=\"docblock\"><p>Returns this <code>String</code>‚Äôs capacity, in bytes.</p>\n<h5 id=\"examples-18\"><a href=\"#examples-18\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = String::with_capacity(<span class=\"number\">10</span>);\n\n<span class=\"macro\">assert!</span>(s.capacity() &gt;= <span class=\"number\">10</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.reserve\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">reserve</a>(&amp;mut self, additional: usize)</h4></section></summary><div class=\"docblock\"><p>Reserves capacity for at least <code>additional</code> bytes more than the\ncurrent length. The allocator may reserve more space to speculatively\navoid frequent allocations. After calling <code>reserve</code>,\ncapacity will be greater than or equal to <code>self.len() + additional</code>.\nDoes nothing if capacity is already sufficient.</p>\n<h5 id=\"panics-1\"><a href=\"#panics-1\">Panics</a></h5>\n<p>Panics if the new capacity overflows [<code>usize</code>].</p>\n<h5 id=\"examples-19\"><a href=\"#examples-19\">Examples</a></h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::new();\n\ns.reserve(<span class=\"number\">10</span>);\n\n<span class=\"macro\">assert!</span>(s.capacity() &gt;= <span class=\"number\">10</span>);</code></pre></div>\n<p>This might not actually increase the capacity:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::with_capacity(<span class=\"number\">10</span>);\ns.push(<span class=\"string\">'a'</span>);\ns.push(<span class=\"string\">'b'</span>);\n\n<span class=\"comment\">// s now has a length of 2 and a capacity of at least 10\n</span><span class=\"kw\">let </span>capacity = s.capacity();\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">2</span>, s.len());\n<span class=\"macro\">assert!</span>(capacity &gt;= <span class=\"number\">10</span>);\n\n<span class=\"comment\">// Since we already have at least an extra 8 capacity, calling this...\n</span>s.reserve(<span class=\"number\">8</span>);\n\n<span class=\"comment\">// ... doesn't actually increase.\n</span><span class=\"macro\">assert_eq!</span>(capacity, s.capacity());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.reserve_exact\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">reserve_exact</a>(&amp;mut self, additional: usize)</h4></section></summary><div class=\"docblock\"><p>Reserves the minimum capacity for at least <code>additional</code> bytes more than\nthe current length. Unlike <a href=\"String::reserve\"><code>reserve</code></a>, this will not\ndeliberately over-allocate to speculatively avoid frequent allocations.\nAfter calling <code>reserve_exact</code>, capacity will be greater than or equal to\n<code>self.len() + additional</code>. Does nothing if the capacity is already\nsufficient.</p>\n<h5 id=\"panics-2\"><a href=\"#panics-2\">Panics</a></h5>\n<p>Panics if the new capacity overflows [<code>usize</code>].</p>\n<h5 id=\"examples-20\"><a href=\"#examples-20\">Examples</a></h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::new();\n\ns.reserve_exact(<span class=\"number\">10</span>);\n\n<span class=\"macro\">assert!</span>(s.capacity() &gt;= <span class=\"number\">10</span>);</code></pre></div>\n<p>This might not actually increase the capacity:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::with_capacity(<span class=\"number\">10</span>);\ns.push(<span class=\"string\">'a'</span>);\ns.push(<span class=\"string\">'b'</span>);\n\n<span class=\"comment\">// s now has a length of 2 and a capacity of at least 10\n</span><span class=\"kw\">let </span>capacity = s.capacity();\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">2</span>, s.len());\n<span class=\"macro\">assert!</span>(capacity &gt;= <span class=\"number\">10</span>);\n\n<span class=\"comment\">// Since we already have at least an extra 8 capacity, calling this...\n</span>s.reserve_exact(<span class=\"number\">8</span>);\n\n<span class=\"comment\">// ... doesn't actually increase.\n</span><span class=\"macro\">assert_eq!</span>(capacity, s.capacity());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_reserve\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.57.0\">1.57.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">try_reserve</a>(&amp;mut self, additional: usize) -&gt; Result&lt;(), TryReserveError&gt;</h4></section></summary><div class=\"docblock\"><p>Tries to reserve capacity for at least <code>additional</code> bytes more than the\ncurrent length. The allocator may reserve more space to speculatively\navoid frequent allocations. After calling <code>try_reserve</code>, capacity will be\ngreater than or equal to <code>self.len() + additional</code> if it returns\n<code>Ok(())</code>. Does nothing if capacity is already sufficient. This method\npreserves the contents even if an error occurs.</p>\n<h5 id=\"errors-1\"><a href=\"#errors-1\">Errors</a></h5>\n<p>If the capacity overflows, or the allocator reports a failure, then an error\nis returned.</p>\n<h5 id=\"examples-21\"><a href=\"#examples-21\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::TryReserveError;\n\n<span class=\"kw\">fn </span>process_data(data: <span class=\"kw-2\">&amp;</span>str) -&gt; <span class=\"prelude-ty\">Result</span>&lt;String, TryReserveError&gt; {\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>output = String::new();\n\n    <span class=\"comment\">// Pre-reserve the memory, exiting if we can't\n    </span>output.try_reserve(data.len())<span class=\"question-mark\">?</span>;\n\n    <span class=\"comment\">// Now we know this can't OOM in the middle of our complex work\n    </span>output.push_str(data);\n\n    <span class=\"prelude-val\">Ok</span>(output)\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_reserve_exact\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.57.0\">1.57.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">try_reserve_exact</a>(\n    &amp;mut self,\n    additional: usize\n) -&gt; Result&lt;(), TryReserveError&gt;</h4></section></summary><div class=\"docblock\"><p>Tries to reserve the minimum capacity for at least <code>additional</code> bytes\nmore than the current length. Unlike <a href=\"String::try_reserve\"><code>try_reserve</code></a>, this will not\ndeliberately over-allocate to speculatively avoid frequent allocations.\nAfter calling <code>try_reserve_exact</code>, capacity will be greater than or\nequal to <code>self.len() + additional</code> if it returns <code>Ok(())</code>.\nDoes nothing if the capacity is already sufficient.</p>\n<p>Note that the allocator may give the collection more space than it\nrequests. Therefore, capacity can not be relied upon to be precisely\nminimal. Prefer <a href=\"String::try_reserve\"><code>try_reserve</code></a> if future insertions are expected.</p>\n<h5 id=\"errors-2\"><a href=\"#errors-2\">Errors</a></h5>\n<p>If the capacity overflows, or the allocator reports a failure, then an error\nis returned.</p>\n<h5 id=\"examples-22\"><a href=\"#examples-22\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::collections::TryReserveError;\n\n<span class=\"kw\">fn </span>process_data(data: <span class=\"kw-2\">&amp;</span>str) -&gt; <span class=\"prelude-ty\">Result</span>&lt;String, TryReserveError&gt; {\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>output = String::new();\n\n    <span class=\"comment\">// Pre-reserve the memory, exiting if we can't\n    </span>output.try_reserve_exact(data.len())<span class=\"question-mark\">?</span>;\n\n    <span class=\"comment\">// Now we know this can't OOM in the middle of our complex work\n    </span>output.push_str(data);\n\n    <span class=\"prelude-val\">Ok</span>(output)\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.shrink_to_fit\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">shrink_to_fit</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Shrinks the capacity of this <code>String</code> to match its length.</p>\n<h5 id=\"examples-23\"><a href=\"#examples-23\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"foo\"</span>);\n\ns.reserve(<span class=\"number\">100</span>);\n<span class=\"macro\">assert!</span>(s.capacity() &gt;= <span class=\"number\">100</span>);\n\ns.shrink_to_fit();\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">3</span>, s.capacity());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.shrink_to\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.56.0\">1.56.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">shrink_to</a>(&amp;mut self, min_capacity: usize)</h4></section></summary><div class=\"docblock\"><p>Shrinks the capacity of this <code>String</code> with a lower bound.</p>\n<p>The capacity will remain at least as large as both the length\nand the supplied value.</p>\n<p>If the current capacity is less than the lower limit, this is a no-op.</p>\n<h5 id=\"examples-24\"><a href=\"#examples-24\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"foo\"</span>);\n\ns.reserve(<span class=\"number\">100</span>);\n<span class=\"macro\">assert!</span>(s.capacity() &gt;= <span class=\"number\">100</span>);\n\ns.shrink_to(<span class=\"number\">10</span>);\n<span class=\"macro\">assert!</span>(s.capacity() &gt;= <span class=\"number\">10</span>);\ns.shrink_to(<span class=\"number\">0</span>);\n<span class=\"macro\">assert!</span>(s.capacity() &gt;= <span class=\"number\">3</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.push\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">push</a>(&amp;mut self, ch: char)</h4></section></summary><div class=\"docblock\"><p>Appends the given [<code>char</code>] to the end of this <code>String</code>.</p>\n<h5 id=\"examples-25\"><a href=\"#examples-25\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"abc\"</span>);\n\ns.push(<span class=\"string\">'1'</span>);\ns.push(<span class=\"string\">'2'</span>);\ns.push(<span class=\"string\">'3'</span>);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"abc123\"</span>, s);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_bytes\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">as_bytes</a>(&amp;self) -&gt; &amp;[u8]</h4></section></summary><div class=\"docblock\"><p>Returns a byte slice of this <code>String</code>‚Äôs contents.</p>\n<p>The inverse of this method is <a href=\"String::from_utf8\"><code>from_utf8</code></a>.</p>\n<h5 id=\"examples-26\"><a href=\"#examples-26\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = String::from(<span class=\"string\">\"hello\"</span>);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">104</span>, <span class=\"number\">101</span>, <span class=\"number\">108</span>, <span class=\"number\">108</span>, <span class=\"number\">111</span>], s.as_bytes());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.truncate\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">truncate</a>(&amp;mut self, new_len: usize)</h4></section></summary><div class=\"docblock\"><p>Shortens this <code>String</code> to the specified length.</p>\n<p>If <code>new_len</code> is greater than the string‚Äôs current length, this has no\neffect.</p>\n<p>Note that this method has no effect on the allocated capacity\nof the string</p>\n<h5 id=\"panics-3\"><a href=\"#panics-3\">Panics</a></h5>\n<p>Panics if <code>new_len</code> does not lie on a [<code>char</code>] boundary.</p>\n<h5 id=\"examples-27\"><a href=\"#examples-27\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"hello\"</span>);\n\ns.truncate(<span class=\"number\">2</span>);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"he\"</span>, s);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.pop\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">pop</a>(&amp;mut self) -&gt; Option&lt;char&gt;</h4></section></summary><div class=\"docblock\"><p>Removes the last character from the string buffer and returns it.</p>\n<p>Returns [<code>None</code>] if this <code>String</code> is empty.</p>\n<h5 id=\"examples-28\"><a href=\"#examples-28\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"abƒç\"</span>);\n\n<span class=\"macro\">assert_eq!</span>(s.pop(), <span class=\"prelude-val\">Some</span>(<span class=\"string\">'ƒç'</span>));\n<span class=\"macro\">assert_eq!</span>(s.pop(), <span class=\"prelude-val\">Some</span>(<span class=\"string\">'b'</span>));\n<span class=\"macro\">assert_eq!</span>(s.pop(), <span class=\"prelude-val\">Some</span>(<span class=\"string\">'a'</span>));\n\n<span class=\"macro\">assert_eq!</span>(s.pop(), <span class=\"prelude-val\">None</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.remove\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">remove</a>(&amp;mut self, idx: usize) -&gt; char</h4></section></summary><div class=\"docblock\"><p>Removes a [<code>char</code>] from this <code>String</code> at a byte position and returns it.</p>\n<p>This is an <em>O</em>(<em>n</em>) operation, as it requires copying every element in the\nbuffer.</p>\n<h5 id=\"panics-4\"><a href=\"#panics-4\">Panics</a></h5>\n<p>Panics if <code>idx</code> is larger than or equal to the <code>String</code>‚Äôs length,\nor if it does not lie on a [<code>char</code>] boundary.</p>\n<h5 id=\"examples-29\"><a href=\"#examples-29\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"ab√ß\"</span>);\n\n<span class=\"macro\">assert_eq!</span>(s.remove(<span class=\"number\">0</span>), <span class=\"string\">'a'</span>);\n<span class=\"macro\">assert_eq!</span>(s.remove(<span class=\"number\">1</span>), <span class=\"string\">'√ß'</span>);\n<span class=\"macro\">assert_eq!</span>(s.remove(<span class=\"number\">0</span>), <span class=\"string\">'b'</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.remove_matches\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">remove_matches</a>&lt;P, 'a&gt;(&amp;'a mut self, pat: P)<div class=\"where\">where\n    P: for&lt;'x&gt; Pattern&lt;'x&gt;,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>string_remove_matches</code>)</span></div></span></summary><div class=\"docblock\"><p>Remove all matches of pattern <code>pat</code> in the <code>String</code>.</p>\n<h5 id=\"examples-30\"><a href=\"#examples-30\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(string_remove_matches)]\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"Trees are not green, the sky is not blue.\"</span>);\ns.remove_matches(<span class=\"string\">\"not \"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"Trees are green, the sky is blue.\"</span>, s);</code></pre></div>\n<p>Matches will be detected and removed iteratively, so in cases where\npatterns overlap, only the first pattern will be removed:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(string_remove_matches)]\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"banana\"</span>);\ns.remove_matches(<span class=\"string\">\"ana\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"bna\"</span>, s);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.retain\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.26.0\">1.26.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">retain</a>&lt;F&gt;(&amp;mut self, f: F)<div class=\"where\">where\n    F: FnMut(char) -&gt; bool,</div></h4></section></summary><div class=\"docblock\"><p>Retains only the characters specified by the predicate.</p>\n<p>In other words, remove all characters <code>c</code> such that <code>f(c)</code> returns <code>false</code>.\nThis method operates in place, visiting each character exactly once in the\noriginal order, and preserves the order of the retained characters.</p>\n<h5 id=\"examples-31\"><a href=\"#examples-31\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"f_o_ob_ar\"</span>);\n\ns.retain(|c| c != <span class=\"string\">'_'</span>);\n\n<span class=\"macro\">assert_eq!</span>(s, <span class=\"string\">\"foobar\"</span>);</code></pre></div>\n<p>Because the elements are visited exactly once in the original order,\nexternal state may be used to decide which elements to keep.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"abcde\"</span>);\n<span class=\"kw\">let </span>keep = [<span class=\"bool-val\">false</span>, <span class=\"bool-val\">true</span>, <span class=\"bool-val\">true</span>, <span class=\"bool-val\">false</span>, <span class=\"bool-val\">true</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = keep.iter();\ns.retain(|<span class=\"kw\">_</span>| <span class=\"kw-2\">*</span>iter.next().unwrap());\n<span class=\"macro\">assert_eq!</span>(s, <span class=\"string\">\"bce\"</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.insert\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">insert</a>(&amp;mut self, idx: usize, ch: char)</h4></section></summary><div class=\"docblock\"><p>Inserts a character into this <code>String</code> at a byte position.</p>\n<p>This is an <em>O</em>(<em>n</em>) operation as it requires copying every element in the\nbuffer.</p>\n<h5 id=\"panics-5\"><a href=\"#panics-5\">Panics</a></h5>\n<p>Panics if <code>idx</code> is larger than the <code>String</code>‚Äôs length, or if it does not\nlie on a [<code>char</code>] boundary.</p>\n<h5 id=\"examples-32\"><a href=\"#examples-32\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::with_capacity(<span class=\"number\">3</span>);\n\ns.insert(<span class=\"number\">0</span>, <span class=\"string\">'f'</span>);\ns.insert(<span class=\"number\">1</span>, <span class=\"string\">'o'</span>);\ns.insert(<span class=\"number\">2</span>, <span class=\"string\">'o'</span>);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"foo\"</span>, s);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.insert_str\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.16.0\">1.16.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">insert_str</a>(&amp;mut self, idx: usize, string: &amp;str)</h4></section></summary><div class=\"docblock\"><p>Inserts a string slice into this <code>String</code> at a byte position.</p>\n<p>This is an <em>O</em>(<em>n</em>) operation as it requires copying every element in the\nbuffer.</p>\n<h5 id=\"panics-6\"><a href=\"#panics-6\">Panics</a></h5>\n<p>Panics if <code>idx</code> is larger than the <code>String</code>‚Äôs length, or if it does not\nlie on a [<code>char</code>] boundary.</p>\n<h5 id=\"examples-33\"><a href=\"#examples-33\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"bar\"</span>);\n\ns.insert_str(<span class=\"number\">0</span>, <span class=\"string\">\"foo\"</span>);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"foobar\"</span>, s);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_mut_vec\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub unsafe fn <a class=\"fn\">as_mut_vec</a>(&amp;mut self) -&gt; &amp;mut Vec&lt;u8&gt;</h4></section></summary><div class=\"docblock\"><p>Returns a mutable reference to the contents of this <code>String</code>.</p>\n<h5 id=\"safety-2\"><a href=\"#safety-2\">Safety</a></h5>\n<p>This function is unsafe because the returned <code>&amp;mut Vec</code> allows writing\nbytes which are not valid UTF-8. If this constraint is violated, using\nthe original <code>String</code> after dropping the <code>&amp;mut Vec</code> may violate memory\nsafety, as the rest of the standard library assumes that <code>String</code>s are\nvalid UTF-8.</p>\n<h5 id=\"examples-34\"><a href=\"#examples-34\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"hello\"</span>);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>vec = s.as_mut_vec();\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">104</span>, <span class=\"number\">101</span>, <span class=\"number\">108</span>, <span class=\"number\">108</span>, <span class=\"number\">111</span>][..], <span class=\"kw-2\">&amp;</span>vec[..]);\n\n    vec.reverse();\n}\n<span class=\"macro\">assert_eq!</span>(s, <span class=\"string\">\"olleh\"</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.len\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">len</a>(&amp;self) -&gt; usize</h4></section></summary><div class=\"docblock\"><p>Returns the length of this <code>String</code>, in bytes, not [<code>char</code>]s or\ngraphemes. In other words, it might not be what a human considers the\nlength of the string.</p>\n<h5 id=\"examples-35\"><a href=\"#examples-35\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = String::from(<span class=\"string\">\"foo\"</span>);\n<span class=\"macro\">assert_eq!</span>(a.len(), <span class=\"number\">3</span>);\n\n<span class=\"kw\">let </span>fancy_f = String::from(<span class=\"string\">\"∆íoo\"</span>);\n<span class=\"macro\">assert_eq!</span>(fancy_f.len(), <span class=\"number\">4</span>);\n<span class=\"macro\">assert_eq!</span>(fancy_f.chars().count(), <span class=\"number\">3</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_empty\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">is_empty</a>(&amp;self) -&gt; bool</h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if this <code>String</code> has a length of zero, and <code>false</code> otherwise.</p>\n<h5 id=\"examples-36\"><a href=\"#examples-36\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = String::new();\n<span class=\"macro\">assert!</span>(v.is_empty());\n\nv.push(<span class=\"string\">'a'</span>);\n<span class=\"macro\">assert!</span>(!v.is_empty());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.split_off\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.16.0\">1.16.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">split_off</a>(&amp;mut self, at: usize) -&gt; String</h4></section></summary><div class=\"docblock\"><p>Splits the string into two at the given byte index.</p>\n<p>Returns a newly allocated <code>String</code>. <code>self</code> contains bytes <code>[0, at)</code>, and\nthe returned <code>String</code> contains bytes <code>[at, len)</code>. <code>at</code> must be on the\nboundary of a UTF-8 code point.</p>\n<p>Note that the capacity of <code>self</code> does not change.</p>\n<h5 id=\"panics-7\"><a href=\"#panics-7\">Panics</a></h5>\n<p>Panics if <code>at</code> is not on a <code>UTF-8</code> code point boundary, or if it is beyond the last\ncode point of the string.</p>\n<h5 id=\"examples-37\"><a href=\"#examples-37\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>hello = String::from(<span class=\"string\">\"Hello, World!\"</span>);\n<span class=\"kw\">let </span>world = hello.split_off(<span class=\"number\">7</span>);\n<span class=\"macro\">assert_eq!</span>(hello, <span class=\"string\">\"Hello, \"</span>);\n<span class=\"macro\">assert_eq!</span>(world, <span class=\"string\">\"World!\"</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clear\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">clear</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Truncates this <code>String</code>, removing all contents.</p>\n<p>While this means the <code>String</code> will have a length of zero, it does not\ntouch its capacity.</p>\n<h5 id=\"examples-38\"><a href=\"#examples-38\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"foo\"</span>);\n\ns.clear();\n\n<span class=\"macro\">assert!</span>(s.is_empty());\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">0</span>, s.len());\n<span class=\"macro\">assert_eq!</span>(<span class=\"number\">3</span>, s.capacity());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.drain\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.6.0\">1.6.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">drain</a>&lt;R&gt;(&amp;mut self, range: R) -&gt; Drain&lt;'_&gt;<div class=\"where\">where\n    R: RangeBounds&lt;usize&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Removes the specified range from the string in bulk, returning all\nremoved characters as an iterator.</p>\n<p>The returned iterator keeps a mutable borrow on the string to optimize\nits implementation.</p>\n<h5 id=\"panics-8\"><a href=\"#panics-8\">Panics</a></h5>\n<p>Panics if the starting point or end point do not lie on a [<code>char</code>]\nboundary, or if they‚Äôre out of bounds.</p>\n<h5 id=\"leaking\"><a href=\"#leaking\">Leaking</a></h5>\n<p>If the returned iterator goes out of scope without being dropped (due to\n[<code>core::mem::forget</code>], for example), the string may still contain a copy\nof any drained characters, or may have lost characters arbitrarily,\nincluding characters outside the range.</p>\n<h5 id=\"examples-39\"><a href=\"#examples-39\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"Œ± is alpha, Œ≤ is beta\"</span>);\n<span class=\"kw\">let </span>beta_offset = s.find(<span class=\"string\">'Œ≤'</span>).unwrap_or(s.len());\n\n<span class=\"comment\">// Remove the range up until the Œ≤ from the string\n</span><span class=\"kw\">let </span>t: String = s.drain(..beta_offset).collect();\n<span class=\"macro\">assert_eq!</span>(t, <span class=\"string\">\"Œ± is alpha, \"</span>);\n<span class=\"macro\">assert_eq!</span>(s, <span class=\"string\">\"Œ≤ is beta\"</span>);\n\n<span class=\"comment\">// A full range clears the string, like `clear()` does\n</span>s.drain(..);\n<span class=\"macro\">assert_eq!</span>(s, <span class=\"string\">\"\"</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.replace_range\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.27.0\">1.27.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">replace_range</a>&lt;R&gt;(&amp;mut self, range: R, replace_with: &amp;str)<div class=\"where\">where\n    R: RangeBounds&lt;usize&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Removes the specified range in the string,\nand replaces it with the given string.\nThe given string doesn‚Äôt need to be the same length as the range.</p>\n<h5 id=\"panics-9\"><a href=\"#panics-9\">Panics</a></h5>\n<p>Panics if the starting point or end point do not lie on a [<code>char</code>]\nboundary, or if they‚Äôre out of bounds.</p>\n<h5 id=\"examples-40\"><a href=\"#examples-40\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = String::from(<span class=\"string\">\"Œ± is alpha, Œ≤ is beta\"</span>);\n<span class=\"kw\">let </span>beta_offset = s.find(<span class=\"string\">'Œ≤'</span>).unwrap_or(s.len());\n\n<span class=\"comment\">// Replace the range up until the Œ≤ from the string\n</span>s.replace_range(..beta_offset, <span class=\"string\">\"Œë is capital alpha; \"</span>);\n<span class=\"macro\">assert_eq!</span>(s, <span class=\"string\">\"Œë is capital alpha; Œ≤ is beta\"</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.into_boxed_str\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.4.0\">1.4.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">into_boxed_str</a>(self) -&gt; Box&lt;str&gt;</h4></section></summary><div class=\"docblock\"><p>Converts this <code>String</code> into a <code>[Box]&lt;<a href=\"prim@str\" title=\"str\">str</a>&gt;</code>.</p>\n<p>This will drop any excess capacity.</p>\n<h5 id=\"examples-41\"><a href=\"#examples-41\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = String::from(<span class=\"string\">\"hello\"</span>);\n\n<span class=\"kw\">let </span>b = s.into_boxed_str();</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.leak\" class=\"method\"><span class=\"since rightside\" title=\"Stable since Rust version 1.72.0\">1.72.0</span><h4 class=\"code-header\">pub fn <a class=\"fn\">leak</a>&lt;'a&gt;(self) -&gt; &amp;'a mut str</h4></section></summary><div class=\"docblock\"><p>Consumes and leaks the <code>String</code>, returning a mutable reference to the contents,\n<code>&amp;'a mut str</code>.</p>\n<p>The caller has free choice over the returned lifetime, including <code>'static</code>. Indeed,\nthis function is ideally used for data that lives for the remainder of the program‚Äôs life,\nas dropping the returned reference will cause a memory leak.</p>\n<p>It does not reallocate or shrink the <code>String</code>,\nso the leaked allocation may include unused capacity that is not part\nof the returned slice. If you don‚Äôt want that, call <a href=\"Self::into_boxed_str\"><code>into_boxed_str</code></a>,\nand then [<code>Box::leak</code>].</p>\n<h5 id=\"examples-42\"><a href=\"#examples-42\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = String::from(<span class=\"string\">\"bucket\"</span>);\n<span class=\"kw\">let </span>static_ref: <span class=\"kw-2\">&amp;</span><span class=\"lifetime\">'static </span><span class=\"kw-2\">mut </span>str = x.leak();\n<span class=\"macro\">assert_eq!</span>(static_ref, <span class=\"string\">\"bucket\"</span>);</code></pre></div>\n</div></details></div></details>",0,"ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-BorrowMut%3Cstr%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.36.0\">1.36.0</span><a href=\"#impl-BorrowMut%3Cstr%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl BorrowMut&lt;str&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.borrow_mut\" class=\"method trait-impl\"><a href=\"#method.borrow_mut\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut str</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a>Read more</a></div></details></div></details>","BorrowMut<str>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialEq%3C%26str%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-PartialEq%3C%26str%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a, 'b&gt; PartialEq&lt;&amp;'a str&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.eq\" class=\"method trait-impl\"><a href=\"#method.eq\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">eq</a>(&amp;self, other: &amp;&amp;'a str) -&gt; bool</h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used\nby <code>==</code>.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ne\" class=\"method trait-impl\"><a href=\"#method.ne\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">ne</a>(&amp;self, other: &amp;&amp;'a str) -&gt; bool</h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always\nsufficient, and should not be overridden without very good reason.</div></details></div></details>","PartialEq<&'a str>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialEq%3Cstr%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-PartialEq%3Cstr%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a, 'b&gt; PartialEq&lt;str&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.eq\" class=\"method trait-impl\"><a href=\"#method.eq\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">eq</a>(&amp;self, other: &amp;str) -&gt; bool</h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used\nby <code>==</code>.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ne\" class=\"method trait-impl\"><a href=\"#method.ne\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">ne</a>(&amp;self, other: &amp;str) -&gt; bool</h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always\nsufficient, and should not be overridden without very good reason.</div></details></div></details>","PartialEq<str>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialEq%3CCow%3C'a,+str%3E%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-PartialEq%3CCow%3C'a,+str%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a, 'b&gt; PartialEq&lt;Cow&lt;'a, str&gt;&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.eq\" class=\"method trait-impl\"><a href=\"#method.eq\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">eq</a>(&amp;self, other: &amp;Cow&lt;'a, str&gt;) -&gt; bool</h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used\nby <code>==</code>.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ne\" class=\"method trait-impl\"><a href=\"#method.ne\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">ne</a>(&amp;self, other: &amp;Cow&lt;'a, str&gt;) -&gt; bool</h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always\nsufficient, and should not be overridden without very good reason.</div></details></div></details>","PartialEq<Cow<'a, str>>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialEq-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-PartialEq-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl PartialEq for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.eq\" class=\"method trait-impl\"><a href=\"#method.eq\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">eq</a>(&amp;self, other: &amp;String) -&gt; bool</h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used\nby <code>==</code>.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ne\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.ne\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">ne</a>(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always\nsufficient, and should not be overridden without very good reason.</div></details></div></details>","PartialEq","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Add%3C%26str%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Add%3C%26str%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl Add&lt;&amp;str&gt; for String</h3></section></summary><div class=\"docblock\"><p>Implements the <code>+</code> operator for concatenating two strings.</p>\n<p>This consumes the <code>String</code> on the left-hand side and re-uses its buffer (growing it if\nnecessary). This is done to avoid allocating a new <code>String</code> and copying the entire contents on\nevery operation, which would lead to <em>O</em>(<em>n</em>^2) running time when building an <em>n</em>-byte string by\nrepeated concatenation.</p>\n<p>The string on the right-hand side is only borrowed; its contents are copied into the returned\n<code>String</code>.</p>\n<h4 id=\"examples\"><a href=\"#examples\">Examples</a></h4>\n<p>Concatenating two <code>String</code>s takes the first by value and borrows the second:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = String::from(<span class=\"string\">\"hello\"</span>);\n<span class=\"kw\">let </span>b = String::from(<span class=\"string\">\" world\"</span>);\n<span class=\"kw\">let </span>c = a + <span class=\"kw-2\">&amp;</span>b;\n<span class=\"comment\">// `a` is moved and can no longer be used here.</span></code></pre></div>\n<p>If you want to keep using the first <code>String</code>, you can clone it and append to the clone instead:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = String::from(<span class=\"string\">\"hello\"</span>);\n<span class=\"kw\">let </span>b = String::from(<span class=\"string\">\" world\"</span>);\n<span class=\"kw\">let </span>c = a.clone() + <span class=\"kw-2\">&amp;</span>b;\n<span class=\"comment\">// `a` is still valid here.</span></code></pre></div>\n<p>Concatenating <code>&amp;str</code> slices can be done by converting the first to a <code>String</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = <span class=\"string\">\"hello\"</span>;\n<span class=\"kw\">let </span>b = <span class=\"string\">\" world\"</span>;\n<span class=\"kw\">let </span>c = a.to_string() + b;</code></pre></div>\n</div><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Output</a> = String</h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.add\" class=\"method trait-impl\"><a href=\"#method.add\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">add</a>(self, other: &amp;str) -&gt; String</h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a>Read more</a></div></details></div></details>","Add<&str>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Borrow%3Cstr%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Borrow%3Cstr%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl Borrow&lt;str&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.borrow\" class=\"method trait-impl\"><a href=\"#method.borrow\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">borrow</a>(&amp;self) -&gt; &amp;str</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a>Read more</a></div></details></div></details>","Borrow<str>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Hash-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Hash-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl Hash for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.hash\" class=\"method trait-impl\"><a href=\"#method.hash\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">hash</a>&lt;H&gt;(&amp;self, hasher: &amp;mut H)<div class=\"where\">where\n    H: Hasher,</div></h4></section></summary><div class='docblock'>Feeds this value into the given [<code>Hasher</code>]. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.hash_slice\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.3.0\">1.3.0</span><a href=\"#method.hash_slice\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: &amp;mut H)<div class=\"where\">where\n    H: Hasher,\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given [<code>Hasher</code>]. <a>Read more</a></div></details></div></details>","Hash","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsMut%3Cstr%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.43.0\">1.43.0</span><a href=\"#impl-AsMut%3Cstr%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl AsMut&lt;str&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_mut\" class=\"method trait-impl\"><a href=\"#method.as_mut\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">as_mut</a>(&amp;mut self) -&gt; &amp;mut str</h4></section></summary><div class='docblock'>Converts this type into a mutable reference of the (usually inferred) input type.</div></details></div></details>","AsMut<str>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-From%3C%26str%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-From%3C%26str%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl From&lt;&amp;str&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from\" class=\"method trait-impl\"><a href=\"#method.from\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">from</a>(s: &amp;str) -&gt; String</h4></section></summary><div class=\"docblock\"><p>Converts a <code>&amp;str</code> into a [<code>String</code>].</p>\n<p>The result is allocated on the heap.</p>\n</div></details></div></details>","From<&str>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-From%3C%26mut+str%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.44.0\">1.44.0</span><a href=\"#impl-From%3C%26mut+str%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl From&lt;&amp;mut str&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from\" class=\"method trait-impl\"><a href=\"#method.from\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">from</a>(s: &amp;mut str) -&gt; String</h4></section></summary><div class=\"docblock\"><p>Converts a <code>&amp;mut str</code> into a [<code>String</code>].</p>\n<p>The result is allocated on the heap.</p>\n</div></details></div></details>","From<&mut str>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-From%3CCow%3C'a,+str%3E%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.14.0\">1.14.0</span><a href=\"#impl-From%3CCow%3C'a,+str%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a&gt; From&lt;Cow&lt;'a, str&gt;&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from\" class=\"method trait-impl\"><a href=\"#method.from\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">from</a>(s: Cow&lt;'a, str&gt;) -&gt; String</h4></section></summary><div class=\"docblock\"><p>Converts a clone-on-write string to an owned\ninstance of [<code>String</code>].</p>\n<p>This extracts the owned string,\nclones the string if it is not already owned.</p>\n<h5 id=\"example\"><a href=\"#example\">Example</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// If the string is not owned...\n</span><span class=\"kw\">let </span>cow: Cow&lt;<span class=\"lifetime\">'_</span>, str&gt; = Cow::Borrowed(<span class=\"string\">\"eggplant\"</span>);\n<span class=\"comment\">// It will allocate on the heap and copy the string.\n</span><span class=\"kw\">let </span>owned: String = String::from(cow);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>owned[..], <span class=\"string\">\"eggplant\"</span>);</code></pre></div>\n</div></details></div></details>","From<Cow<'a, str>>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-From%3CBox%3Cstr%3E%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.18.0\">1.18.0</span><a href=\"#impl-From%3CBox%3Cstr%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl From&lt;Box&lt;str&gt;&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from\" class=\"method trait-impl\"><a href=\"#method.from\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">from</a>(s: Box&lt;str&gt;) -&gt; String</h4></section></summary><div class=\"docblock\"><p>Converts the given boxed <code>str</code> slice to a [<code>String</code>].\nIt is notable that the <code>str</code> slice is owned.</p>\n<h5 id=\"examples\"><a href=\"#examples\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s1: String = String::from(<span class=\"string\">\"hello world\"</span>);\n<span class=\"kw\">let </span>s2: Box&lt;str&gt; = s1.into_boxed_str();\n<span class=\"kw\">let </span>s3: String = String::from(s2);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"hello world\"</span>, s3)</code></pre></div>\n</div></details></div></details>","From<Box<str>>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-From%3Cchar%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.46.0\">1.46.0</span><a href=\"#impl-From%3Cchar%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl From&lt;char&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from\" class=\"method trait-impl\"><a href=\"#method.from\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">from</a>(c: char) -&gt; String</h4></section></summary><div class=\"docblock\"><p>Allocates an owned [<code>String</code>] from a single character.</p>\n<h5 id=\"example\"><a href=\"#example\">Example</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>c: char = <span class=\"string\">'a'</span>;\n<span class=\"kw\">let </span>s: String = String::from(c);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">\"a\"</span>, <span class=\"kw-2\">&amp;</span>s[..]);</code></pre></div>\n</div></details></div></details>","From<char>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-From%3C%26String%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.35.0\">1.35.0</span><a href=\"#impl-From%3C%26String%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl From&lt;&amp;String&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from\" class=\"method trait-impl\"><a href=\"#method.from\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">from</a>(s: &amp;String) -&gt; String</h4></section></summary><div class=\"docblock\"><p>Converts a <code>&amp;String</code> into a [<code>String</code>].</p>\n<p>This clones <code>s</code> and returns the clone.</p>\n</div></details></div></details>","From<&String>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-FromStr-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-FromStr-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl FromStr for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Err\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Err\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Err</a> = Infallible</h4></section></summary><div class='docblock'>The associated error which can be returned from parsing.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_str\" class=\"method trait-impl\"><a href=\"#method.from_str\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">from_str</a>(s: &amp;str) -&gt; Result&lt;String, &lt;String as FromStr&gt;::Err&gt;</h4></section></summary><div class='docblock'>Parses a string <code>s</code> to return a value of this type. <a>Read more</a></div></details></div></details>","FromStr","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Write-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Write-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl Write for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_str\" class=\"method trait-impl\"><a href=\"#method.write_str\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">write_str</a>(&amp;mut self, s: &amp;str) -&gt; Result&lt;(), Error&gt;</h4></section></summary><div class='docblock'>Writes a string slice into this writer, returning whether the write\nsucceeded. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_char\" class=\"method trait-impl\"><a href=\"#method.write_char\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">write_char</a>(&amp;mut self, c: char) -&gt; Result&lt;(), Error&gt;</h4></section></summary><div class='docblock'>Writes a [<code>char</code>] into this writer, returning whether the write succeeded. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.write_fmt\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.write_fmt\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">write_fmt</a>(&amp;mut self, args: Arguments&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</h4></section></summary><div class='docblock'>Glue for usage of the [<code>write!</code>] macro with implementors of this trait. <a>Read more</a></div></details></div></details>","Write","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Default-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Default-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl Default for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.default\" class=\"method trait-impl\"><a href=\"#method.default\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">default</a>() -&gt; String</h4></section></summary><div class=\"docblock\"><p>Creates an empty <code>String</code>.</p>\n</div></details></div></details>","Default","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-DerefMut-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.3.0\">1.3.0</span><a href=\"#impl-DerefMut-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl DerefMut for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.deref_mut\" class=\"method trait-impl\"><a href=\"#method.deref_mut\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">deref_mut</a>(&amp;mut self) -&gt; &amp;mut str</h4></section></summary><div class='docblock'>Mutably dereferences the value.</div></details></div></details>","DerefMut","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialOrd-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-PartialOrd-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl PartialOrd for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.partial_cmp\" class=\"method trait-impl\"><a href=\"#method.partial_cmp\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">partial_cmp</a>(&amp;self, other: &amp;String) -&gt; Option&lt;Ordering&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.lt\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.lt\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">lt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class='docblock'>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.le\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.le\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">le</a>(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class='docblock'>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>\noperator. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.gt\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.gt\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">gt</a>(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class='docblock'>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ge\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#method.ge\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">ge</a>(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class='docblock'>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>\noperator. <a>Read more</a></div></details></div></details>","PartialOrd","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Ord-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Ord-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl Ord for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.cmp\" class=\"method trait-impl\"><a href=\"#method.cmp\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">cmp</a>(&amp;self, other: &amp;String) -&gt; Ordering</h4></section></summary><div class='docblock'>This method returns an [<code>Ordering</code>] between <code>self</code> and <code>other</code>. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.max\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.21.0\">1.21.0</span><a href=\"#method.max\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">max</a>(self, other: Self) -&gt; Self<div class=\"where\">where\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Compares and returns the maximum of two values. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.min\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.21.0\">1.21.0</span><a href=\"#method.min\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">min</a>(self, other: Self) -&gt; Self<div class=\"where\">where\n    Self: Sized,</div></h4></section></summary><div class='docblock'>Compares and returns the minimum of two values. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clamp\" class=\"method trait-impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.50.0\">1.50.0</span><a href=\"#method.clamp\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class=\"where\">where\n    Self: Sized + PartialOrd,</div></h4></section></summary><div class='docblock'>Restrict a value to a certain interval. <a>Read more</a></div></details></div></details>","Ord","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Clone-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Clone-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl Clone for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone\" class=\"method trait-impl\"><a href=\"#method.clone\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">clone</a>(&amp;self) -&gt; String</h4></section></summary><div class='docblock'>Returns a copy of the value. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone_from\" class=\"method trait-impl\"><a href=\"#method.clone_from\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">clone_from</a>(&amp;mut self, source: &amp;String)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a>Read more</a></div></details></div></details>","Clone","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Deref-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Deref-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl Deref for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Target\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Target\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Target</a> = str</h4></section></summary><div class='docblock'>The resulting type after dereferencing.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.deref\" class=\"method trait-impl\"><a href=\"#method.deref\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">deref</a>(&amp;self) -&gt; &amp;str</h4></section></summary><div class='docblock'>Dereferences the value.</div></details></div></details>","Deref","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-IndexMut%3CRangeTo%3Cusize%3E%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.3.0\">1.3.0</span><a href=\"#impl-IndexMut%3CRangeTo%3Cusize%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl IndexMut&lt;RangeTo&lt;usize&gt;&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.index_mut\" class=\"method trait-impl\"><a href=\"#method.index_mut\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">index_mut</a>(&amp;mut self, index: RangeTo&lt;usize&gt;) -&gt; &amp;mut str</h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a>Read more</a></div></details></div></details>","IndexMut<RangeTo<usize>>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-IndexMut%3CRangeFrom%3Cusize%3E%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.3.0\">1.3.0</span><a href=\"#impl-IndexMut%3CRangeFrom%3Cusize%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl IndexMut&lt;RangeFrom&lt;usize&gt;&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.index_mut\" class=\"method trait-impl\"><a href=\"#method.index_mut\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">index_mut</a>(&amp;mut self, index: RangeFrom&lt;usize&gt;) -&gt; &amp;mut str</h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a>Read more</a></div></details></div></details>","IndexMut<RangeFrom<usize>>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-IndexMut%3CRangeFull%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.3.0\">1.3.0</span><a href=\"#impl-IndexMut%3CRangeFull%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl IndexMut&lt;RangeFull&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.index_mut\" class=\"method trait-impl\"><a href=\"#method.index_mut\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">index_mut</a>(&amp;mut self, _index: RangeFull) -&gt; &amp;mut str</h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a>Read more</a></div></details></div></details>","IndexMut<RangeFull>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-IndexMut%3CRangeToInclusive%3Cusize%3E%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.26.0\">1.26.0</span><a href=\"#impl-IndexMut%3CRangeToInclusive%3Cusize%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl IndexMut&lt;RangeToInclusive&lt;usize&gt;&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.index_mut\" class=\"method trait-impl\"><a href=\"#method.index_mut\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">index_mut</a>(&amp;mut self, index: RangeToInclusive&lt;usize&gt;) -&gt; &amp;mut str</h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a>Read more</a></div></details></div></details>","IndexMut<RangeToInclusive<usize>>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-IndexMut%3CRangeInclusive%3Cusize%3E%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.26.0\">1.26.0</span><a href=\"#impl-IndexMut%3CRangeInclusive%3Cusize%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl IndexMut&lt;RangeInclusive&lt;usize&gt;&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.index_mut\" class=\"method trait-impl\"><a href=\"#method.index_mut\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">index_mut</a>(&amp;mut self, index: RangeInclusive&lt;usize&gt;) -&gt; &amp;mut str</h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a>Read more</a></div></details></div></details>","IndexMut<RangeInclusive<usize>>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-IndexMut%3CRange%3Cusize%3E%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.3.0\">1.3.0</span><a href=\"#impl-IndexMut%3CRange%3Cusize%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl IndexMut&lt;Range&lt;usize&gt;&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.index_mut\" class=\"method trait-impl\"><a href=\"#method.index_mut\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">index_mut</a>(&amp;mut self, index: Range&lt;usize&gt;) -&gt; &amp;mut str</h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a>Read more</a></div></details></div></details>","IndexMut<Range<usize>>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-FromIterator%3CCow%3C'a,+str%3E%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.19.0\">1.19.0</span><a href=\"#impl-FromIterator%3CCow%3C'a,+str%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a&gt; FromIterator&lt;Cow&lt;'a, str&gt;&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_iter\" class=\"method trait-impl\"><a href=\"#method.from_iter\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">from_iter</a>&lt;I&gt;(iter: I) -&gt; String<div class=\"where\">where\n    I: IntoIterator&lt;Item = Cow&lt;'a, str&gt;&gt;,</div></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a>Read more</a></div></details></div></details>","FromIterator<Cow<'a, str>>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-FromIterator%3C%26str%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-FromIterator%3C%26str%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a&gt; FromIterator&lt;&amp;'a str&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_iter\" class=\"method trait-impl\"><a href=\"#method.from_iter\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">from_iter</a>&lt;I&gt;(iter: I) -&gt; String<div class=\"where\">where\n    I: IntoIterator&lt;Item = &amp;'a str&gt;,</div></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a>Read more</a></div></details></div></details>","FromIterator<&'a str>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-FromIterator%3Cchar%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-FromIterator%3Cchar%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl FromIterator&lt;char&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_iter\" class=\"method trait-impl\"><a href=\"#method.from_iter\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">from_iter</a>&lt;I&gt;(iter: I) -&gt; String<div class=\"where\">where\n    I: IntoIterator&lt;Item = char&gt;,</div></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a>Read more</a></div></details></div></details>","FromIterator<char>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-FromIterator%3C%26char%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.17.0\">1.17.0</span><a href=\"#impl-FromIterator%3C%26char%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a&gt; FromIterator&lt;&amp;'a char&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_iter\" class=\"method trait-impl\"><a href=\"#method.from_iter\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">from_iter</a>&lt;I&gt;(iter: I) -&gt; String<div class=\"where\">where\n    I: IntoIterator&lt;Item = &amp;'a char&gt;,</div></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a>Read more</a></div></details></div></details>","FromIterator<&'a char>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-FromIterator%3CString%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.4.0\">1.4.0</span><a href=\"#impl-FromIterator%3CString%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl FromIterator&lt;String&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_iter\" class=\"method trait-impl\"><a href=\"#method.from_iter\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">from_iter</a>&lt;I&gt;(iter: I) -&gt; String<div class=\"where\">where\n    I: IntoIterator&lt;Item = String&gt;,</div></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a>Read more</a></div></details></div></details>","FromIterator<String>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-FromIterator%3CBox%3Cstr%3E%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.45.0\">1.45.0</span><a href=\"#impl-FromIterator%3CBox%3Cstr%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl FromIterator&lt;Box&lt;str&gt;&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_iter\" class=\"method trait-impl\"><a href=\"#method.from_iter\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">from_iter</a>&lt;I&gt;(iter: I) -&gt; String<div class=\"where\">where\n    I: IntoIterator&lt;Item = Box&lt;str&gt;&gt;,</div></h4></section></summary><div class='docblock'>Creates a value from an iterator. <a>Read more</a></div></details></div></details>","FromIterator<Box<str>>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Display-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Display-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl Display for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a href=\"#method.fmt\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">fmt</a>(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a>Read more</a></div></details></div></details>","Display","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsRef%3Cstr%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-AsRef%3Cstr%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl AsRef&lt;str&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_ref\" class=\"method trait-impl\"><a href=\"#method.as_ref\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">as_ref</a>(&amp;self) -&gt; &amp;str</h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details>","AsRef<str>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsRef%3C%5Bu8%5D%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-AsRef%3C%5Bu8%5D%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl AsRef&lt;[u8]&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_ref\" class=\"method trait-impl\"><a href=\"#method.as_ref\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">as_ref</a>(&amp;self) -&gt; &amp;[u8]</h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details>","AsRef<[u8]>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AddAssign%3C%26str%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.12.0\">1.12.0</span><a href=\"#impl-AddAssign%3C%26str%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl AddAssign&lt;&amp;str&gt; for String</h3></section></summary><div class=\"docblock\"><p>Implements the <code>+=</code> operator for appending to a <code>String</code>.</p>\n<p>This has the same behavior as the [<code>push_str</code>][String::push_str] method.</p>\n</div><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.add_assign\" class=\"method trait-impl\"><a href=\"#method.add_assign\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">add_assign</a>(&amp;mut self, other: &amp;str)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a>Read more</a></div></details></div></details>","AddAssign<&str>","ktest::path::PathElement"],["<section id=\"impl-StructuralPartialEq-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-StructuralPartialEq-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl StructuralPartialEq for String</h3></section>","StructuralPartialEq","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Extend%3CBox%3Cstr%3E%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.45.0\">1.45.0</span><a href=\"#impl-Extend%3CBox%3Cstr%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl Extend&lt;Box&lt;str&gt;&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.extend\" class=\"method trait-impl\"><a href=\"#method.extend\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class=\"where\">where\n    I: IntoIterator&lt;Item = Box&lt;str&gt;&gt;,</div></h4></section></summary><div class='docblock'>Extends a collection with the contents of an iterator. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.extend_one\" class=\"method trait-impl\"><a href=\"#method.extend_one\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">extend_one</a>(&amp;mut self, item: A)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Extends a collection with exactly one element.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.extend_reserve\" class=\"method trait-impl\"><a href=\"#method.extend_reserve\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">extend_reserve</a>(&amp;mut self, additional: usize)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Reserves capacity in a collection for the given number of additional elements. <a>Read more</a></div></details></div></details>","Extend<Box<str>>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Extend%3CString%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.4.0\">1.4.0</span><a href=\"#impl-Extend%3CString%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl Extend&lt;String&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.extend\" class=\"method trait-impl\"><a href=\"#method.extend\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class=\"where\">where\n    I: IntoIterator&lt;Item = String&gt;,</div></h4></section></summary><div class='docblock'>Extends a collection with the contents of an iterator. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.extend_one\" class=\"method trait-impl\"><a href=\"#method.extend_one\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">extend_one</a>(&amp;mut self, s: String)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Extends a collection with exactly one element.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.extend_reserve\" class=\"method trait-impl\"><a href=\"#method.extend_reserve\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">extend_reserve</a>(&amp;mut self, additional: usize)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Reserves capacity in a collection for the given number of additional elements. <a>Read more</a></div></details></div></details>","Extend<String>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Extend%3C%26str%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Extend%3C%26str%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a&gt; Extend&lt;&amp;'a str&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.extend\" class=\"method trait-impl\"><a href=\"#method.extend\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class=\"where\">where\n    I: IntoIterator&lt;Item = &amp;'a str&gt;,</div></h4></section></summary><div class='docblock'>Extends a collection with the contents of an iterator. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.extend_one\" class=\"method trait-impl\"><a href=\"#method.extend_one\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">extend_one</a>(&amp;mut self, s: &amp;'a str)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Extends a collection with exactly one element.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.extend_reserve\" class=\"method trait-impl\"><a href=\"#method.extend_reserve\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">extend_reserve</a>(&amp;mut self, additional: usize)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Reserves capacity in a collection for the given number of additional elements. <a>Read more</a></div></details></div></details>","Extend<&'a str>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Extend%3CCow%3C'a,+str%3E%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.19.0\">1.19.0</span><a href=\"#impl-Extend%3CCow%3C'a,+str%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a&gt; Extend&lt;Cow&lt;'a, str&gt;&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.extend\" class=\"method trait-impl\"><a href=\"#method.extend\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class=\"where\">where\n    I: IntoIterator&lt;Item = Cow&lt;'a, str&gt;&gt;,</div></h4></section></summary><div class='docblock'>Extends a collection with the contents of an iterator. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.extend_one\" class=\"method trait-impl\"><a href=\"#method.extend_one\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">extend_one</a>(&amp;mut self, s: Cow&lt;'a, str&gt;)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Extends a collection with exactly one element.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.extend_reserve\" class=\"method trait-impl\"><a href=\"#method.extend_reserve\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">extend_reserve</a>(&amp;mut self, additional: usize)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Reserves capacity in a collection for the given number of additional elements. <a>Read more</a></div></details></div></details>","Extend<Cow<'a, str>>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Extend%3Cchar%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Extend%3Cchar%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl Extend&lt;char&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.extend\" class=\"method trait-impl\"><a href=\"#method.extend\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class=\"where\">where\n    I: IntoIterator&lt;Item = char&gt;,</div></h4></section></summary><div class='docblock'>Extends a collection with the contents of an iterator. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.extend_one\" class=\"method trait-impl\"><a href=\"#method.extend_one\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">extend_one</a>(&amp;mut self, c: char)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Extends a collection with exactly one element.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.extend_reserve\" class=\"method trait-impl\"><a href=\"#method.extend_reserve\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">extend_reserve</a>(&amp;mut self, additional: usize)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Reserves capacity in a collection for the given number of additional elements. <a>Read more</a></div></details></div></details>","Extend<char>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Extend%3C%26char%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.2.0\">1.2.0</span><a href=\"#impl-Extend%3C%26char%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl&lt;'a&gt; Extend&lt;&amp;'a char&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.extend\" class=\"method trait-impl\"><a href=\"#method.extend\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">extend</a>&lt;I&gt;(&amp;mut self, iter: I)<div class=\"where\">where\n    I: IntoIterator&lt;Item = &amp;'a char&gt;,</div></h4></section></summary><div class='docblock'>Extends a collection with the contents of an iterator. <a>Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.extend_one\" class=\"method trait-impl\"><a href=\"#method.extend_one\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">extend_one</a>(&amp;mut self, _: &amp;'a char)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Extends a collection with exactly one element.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.extend_reserve\" class=\"method trait-impl\"><a href=\"#method.extend_reserve\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">extend_reserve</a>(&amp;mut self, additional: usize)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">üî¨</span><span>This is a nightly-only experimental API. (<code>extend_one</code>)</span></div></span><div class='docblock'>Reserves capacity in a collection for the given number of additional elements. <a>Read more</a></div></details></div></details>","Extend<&'a char>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Debug-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Debug-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl Debug for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a href=\"#method.fmt\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">fmt</a>(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result&lt;(), Error&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a>Read more</a></div></details></div></details>","Debug","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Index%3CRangeInclusive%3Cusize%3E%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.26.0\">1.26.0</span><a href=\"#impl-Index%3CRangeInclusive%3Cusize%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl Index&lt;RangeInclusive&lt;usize&gt;&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Output</a> = str</h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.index\" class=\"method trait-impl\"><a href=\"#method.index\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">index</a>(&amp;self, index: RangeInclusive&lt;usize&gt;) -&gt; &amp;str</h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a>Read more</a></div></details></div></details>","Index<RangeInclusive<usize>>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Index%3CRange%3Cusize%3E%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Index%3CRange%3Cusize%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl Index&lt;Range&lt;usize&gt;&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Output</a> = str</h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.index\" class=\"method trait-impl\"><a href=\"#method.index\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">index</a>(&amp;self, index: Range&lt;usize&gt;) -&gt; &amp;str</h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a>Read more</a></div></details></div></details>","Index<Range<usize>>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Index%3CRangeFrom%3Cusize%3E%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Index%3CRangeFrom%3Cusize%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl Index&lt;RangeFrom&lt;usize&gt;&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Output</a> = str</h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.index\" class=\"method trait-impl\"><a href=\"#method.index\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">index</a>(&amp;self, index: RangeFrom&lt;usize&gt;) -&gt; &amp;str</h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a>Read more</a></div></details></div></details>","Index<RangeFrom<usize>>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Index%3CRangeTo%3Cusize%3E%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Index%3CRangeTo%3Cusize%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl Index&lt;RangeTo&lt;usize&gt;&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Output</a> = str</h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.index\" class=\"method trait-impl\"><a href=\"#method.index\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">index</a>(&amp;self, index: RangeTo&lt;usize&gt;) -&gt; &amp;str</h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a>Read more</a></div></details></div></details>","Index<RangeTo<usize>>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Index%3CRangeFull%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Index%3CRangeFull%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl Index&lt;RangeFull&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Output</a> = str</h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.index\" class=\"method trait-impl\"><a href=\"#method.index\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">index</a>(&amp;self, _index: RangeFull) -&gt; &amp;str</h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a>Read more</a></div></details></div></details>","Index<RangeFull>","ktest::path::PathElement"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Index%3CRangeToInclusive%3Cusize%3E%3E-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.26.0\">1.26.0</span><a href=\"#impl-Index%3CRangeToInclusive%3Cusize%3E%3E-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl Index&lt;RangeToInclusive&lt;usize&gt;&gt; for String</h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Output</a> = str</h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.index\" class=\"method trait-impl\"><a href=\"#method.index\" class=\"anchor\">¬ß</a><h4 class=\"code-header\">fn <a class=\"fn\">index</a>(&amp;self, index: RangeToInclusive&lt;usize&gt;) -&gt; &amp;str</h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a>Read more</a></div></details></div></details>","Index<RangeToInclusive<usize>>","ktest::path::PathElement"],["<section id=\"impl-StructuralEq-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-StructuralEq-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl StructuralEq for String</h3></section>","StructuralEq","ktest::path::PathElement"],["<section id=\"impl-Eq-for-String\" class=\"impl\"><span class=\"since rightside\" title=\"Stable since Rust version 1.0.0\">1.0.0</span><a href=\"#impl-Eq-for-String\" class=\"anchor\">¬ß</a><h3 class=\"code-header\">impl Eq for String</h3></section>","Eq","ktest::path::PathElement"]]
};if (window.register_type_impls) {window.register_type_impls(type_impls);} else {window.pending_type_impls = type_impls;}})()